{"version":3,"file":"ponyfill.es6.min.mjs","sources":["../../node_modules/web-streams-polyfill/dist/ponyfill.es6.mjs"],"sourcesContent":["/**\n * web-streams-polyfill v3.0.3\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    return undefined;\n}\nfunction getGlobals() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        return global;\n    }\n    return undefined;\n}\nconst globals = getGlobals();\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nconst rethrowAssertionErrorRejection = noop;\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\nconst queueMicrotask = (() => {\n    const globalQueueMicrotask = globals && globals.queueMicrotask;\n    if (typeof globalQueueMicrotask === 'function') {\n        return globalQueueMicrotask;\n    }\n    const resolvedPromise = promiseResolvedWith(undefined);\n    return (fn) => PerformPromiseThen(resolvedPromise, fn);\n})();\nfunction reflectCall(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction promiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(reflectCall(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    if (reader._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    if (reader._closedPromise_resolve === undefined) {\n        return;\n    }\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite = Number.isFinite || function (x) {\n    return typeof x === 'number' && isFinite(x);\n};\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc = Math.trunc || function (v) {\n    return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nfunction isDictionary(x) {\n    return typeof x === 'object' || typeof x === 'function';\n}\nfunction assertDictionary(obj, context) {\n    if (obj !== undefined && !isDictionary(obj)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-callback-functions\nfunction assertFunction(x, context) {\n    if (typeof x !== 'function') {\n        throw new TypeError(`${context} is not a function.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-object\nfunction isObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction assertObject(x, context) {\n    if (!isObject(x)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\nfunction assertRequiredArgument(x, position, context) {\n    if (x === undefined) {\n        throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n    }\n}\nfunction assertRequiredField(x, field, context) {\n    if (x === undefined) {\n        throw new TypeError(`${field} is required in '${context}'.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nfunction convertUnrestrictedDouble(value) {\n    return Number(value);\n}\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\nfunction integerPart(x) {\n    return censorNegativeZero(MathTrunc(x));\n}\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nfunction convertUnsignedLongLongWithEnforceRange(value, context) {\n    const lowerBound = 0;\n    const upperBound = Number.MAX_SAFE_INTEGER;\n    let x = Number(value);\n    x = censorNegativeZero(x);\n    if (!NumberIsFinite(x)) {\n        throw new TypeError(`${context} is not a finite number`);\n    }\n    x = integerPart(x);\n    if (x < lowerBound || x > upperBound) {\n        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n    }\n    if (!NumberIsFinite(x) || x === 0) {\n        return 0;\n    }\n    // TODO Use BigInt if supported?\n    // let xBigInt = BigInt(integerPart(x));\n    // xBigInt = BigInt.asUintN(64, xBigInt);\n    // return Number(xBigInt);\n    return x;\n}\n\nfunction assertReadableStream(x, context) {\n    if (!IsReadableStream(x)) {\n        throw new TypeError(`${context} is not a ReadableStream.`);\n    }\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream) {\n    return new ReadableStreamDefaultReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream, readRequest) {\n    stream._reader._readRequests.push(readRequest);\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    if (done) {\n        readRequest._closeSteps();\n    }\n    else {\n        readRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamDefaultReaderRead(this, readRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultReaderRead(reader, readRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        readRequest._closeSteps();\n    }\n    else if (stream._state === 'errored') {\n        readRequest._errorSteps(stream._storedError);\n    }\n    else {\n        stream._readableStreamController[PullSteps](readRequest);\n    }\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nlet AsyncIteratorPrototype;\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    // We're running inside a ES2018+ environment, but we're compiling to an older syntax.\n    // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.\n    AsyncIteratorPrototype = {\n        // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )\n        // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator\n        [SymbolPolyfill.asyncIterator]() {\n            return this;\n        }\n    };\n    Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nclass ReadableStreamAsyncIteratorImpl {\n    constructor(reader, preventCancel) {\n        this._ongoingPromise = undefined;\n        this._isFinished = false;\n        this._reader = reader;\n        this._preventCancel = preventCancel;\n    }\n    next() {\n        const nextSteps = () => this._nextSteps();\n        this._ongoingPromise = this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n            nextSteps();\n        return this._ongoingPromise;\n    }\n    return(value) {\n        const returnSteps = () => this._returnSteps(value);\n        return this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n            returnSteps();\n    }\n    _nextSteps() {\n        if (this._isFinished) {\n            return Promise.resolve({ value: undefined, done: true });\n        }\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => {\n                this._ongoingPromise = undefined;\n                // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                // FIXME Is this a bug in the specification, or in the test?\n                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n            },\n            _closeSteps: () => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                resolvePromise({ value: undefined, done: true });\n            },\n            _errorSteps: reason => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                rejectPromise(reason);\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promise;\n    }\n    _returnSteps(value) {\n        if (this._isFinished) {\n            return Promise.resolve({ value, done: true });\n        }\n        this._isFinished = true;\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (!this._preventCancel) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ({ value, done: true }));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith({ value, done: true });\n    }\n}\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        return this._asyncIteratorImpl.next();\n    },\n    return(value) {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n        }\n        return this._asyncIteratorImpl.return(value);\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorImpl = impl;\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n        return false;\n    }\n    return true;\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nfunction IsFiniteNonNegativeNumber(v) {\n    if (!IsNonNegativeNumber(v)) {\n        return false;\n    }\n    if (v === Infinity) {\n        return false;\n    }\n    return true;\n}\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    size = Number(size);\n    if (!IsFiniteNonNegativeNumber(size)) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\nfunction CreateArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\nfunction IsDetachedBuffer(O) {\n    return false;\n}\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nclass ReadableStreamBYOBRequest {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n    get view() {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        assertRequiredArgument(bytesWritten, 1, 'respond');\n        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer)) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respondWithNewView');\n        }\n        assertRequiredArgument(view, 1, 'respondWithNewView');\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (view.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (view.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: { enumerable: true },\n    respondWithNewView: { enumerable: true },\n    view: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBRequest',\n        configurable: true\n    });\n}\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableByteStreamController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n    get byobRequest() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        if (this._byobRequest === null && this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n            this._byobRequest = byobRequest;\n        }\n        return this._byobRequest;\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        assertRequiredArgument(chunk, 1, 'enqueue');\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('chunk must be an array buffer view');\n        }\n        if (chunk.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (chunk.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._closeRequested) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        if (this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            firstDescriptor.bytesFilled = 0;\n        }\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            readRequest._chunkSteps(view);\n            return;\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                readRequest._errorSteps(bufferE);\n                return;\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                viewConstructor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        ReadableStreamAddReadRequest(stream, readRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n    }\n}\nObject.defineProperties(ReadableByteStreamController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    byobRequest: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableByteStreamController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === null) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = null;\n    controller._byobRequest = null;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    const buffer = TransferArrayBuffer(view.buffer);\n    const pullIntoDescriptor = {\n        buffer,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        viewConstructor: ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        return;\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        readIntoRequest._closeSteps(emptyView);\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            readIntoRequest._chunkSteps(filledView);\n            return;\n        }\n        if (controller._closeRequested) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream)) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n        throw new RangeError('bytesWritten out of range');\n    }\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        // TODO: Figure out whether we should detach the buffer or not here.\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (ReadableStreamHasDefaultReader(stream)) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream)) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    bytesWritten = Number(bytesWritten);\n    if (!IsFiniteNonNegativeNumber(bytesWritten)) {\n        throw new RangeError('bytesWritten must be a finite');\n    }\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.byteLength !== view.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    firstDescriptor.buffer = view.buffer;\n    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = null;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingByteSource.start !== undefined) {\n        startAlgorithm = () => underlyingByteSource.start(controller);\n    }\n    if (underlyingByteSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingByteSource.pull(controller);\n    }\n    if (underlyingByteSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n    }\n    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize === 0) {\n        throw new TypeError('autoAllocateChunkSize must be greater than 0');\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream) {\n    return new ReadableStreamBYOBReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n    stream._reader._readIntoRequests.push(readIntoRequest);\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    if (done) {\n        readIntoRequest._closeSteps(chunk);\n    }\n    else {\n        readIntoRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        if (!IsReadableByteStreamController(stream._readableStreamController)) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Attempts to reads bytes into view, and returns a promise resolved with the result.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        if (view.buffer.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readIntoRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        readIntoRequest._errorSteps(stream._storedError);\n    }\n    else {\n        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n    }\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nfunction ExtractHighWaterMark(strategy, defaultHWM) {\n    const { highWaterMark } = strategy;\n    if (highWaterMark === undefined) {\n        return defaultHWM;\n    }\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('Invalid highWaterMark');\n    }\n    return highWaterMark;\n}\nfunction ExtractSizeAlgorithm(strategy) {\n    const { size } = strategy;\n    if (!size) {\n        return () => 1;\n    }\n    return size;\n}\n\nfunction convertQueuingStrategy(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    const size = init === null || init === void 0 ? void 0 : init.size;\n    return {\n        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n    };\n}\nfunction convertQueuingStrategySize(fn, context) {\n    assertFunction(fn, context);\n    return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n\nfunction convertUnderlyingSink(original, context) {\n    assertDictionary(original, context);\n    const abort = original === null || original === void 0 ? void 0 : original.abort;\n    const close = original === null || original === void 0 ? void 0 : original.close;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    const write = original === null || original === void 0 ? void 0 : original.write;\n    return {\n        abort: abort === undefined ?\n            undefined :\n            convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n        close: close === undefined ?\n            undefined :\n            convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n        write: write === undefined ?\n            undefined :\n            convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n        type\n    };\n}\nfunction convertUnderlyingSinkAbortCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSinkCloseCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return () => promiseCall(fn, original, []);\n}\nfunction convertUnderlyingSinkStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSinkWriteCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction assertWritableStream(x, context) {\n    if (!IsWritableStream(x)) {\n        throw new TypeError(`${context} is not a WritableStream.`);\n    }\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream {\n    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n        if (rawUnderlyingSink === undefined) {\n            rawUnderlyingSink = null;\n        }\n        else {\n            assertObject(rawUnderlyingSink, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n        InitializeWritableStream(this);\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n    get locked() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    /**\n     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n     * mechanism of the underlying sink.\n     *\n     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n     * the stream) if the stream is currently locked.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('abort'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    /**\n     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n     * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n     *\n     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n     */\n    close() {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('close'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    /**\n     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n     * is locked, no other writer can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n     */\n    getWriter() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\nObject.defineProperties(WritableStream.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    getWriter: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStream',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (!wasAlreadyErroring) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n        assertWritableStream(stream, 'First parameter');\n        if (IsWritableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writers lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.\n     * A producer can use this information to determine the right amount of data to write.\n     *\n     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n     * the writers lock is released.\n     */\n    get desiredSize() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    /**\n     * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions\n     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n     *\n     * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become\n     * rejected.\n     */\n    get ready() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n     */\n    close() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    /**\n     * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.\n     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n     * now on; otherwise, the writer will appear closed.\n     *\n     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n     * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n     * other producers from writing in an interleaved manner.\n     */\n    releaseLock() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    releaseLock: { enumerable: true },\n    write: { enumerable: true },\n    closed: { enumerable: true },\n    desiredSize: { enumerable: true },\n    ready: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultWriter',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return true;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nconst closeSentinel = {};\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nclass WritableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n     *\n     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n     * normal lifecycle of interactions with the underlying sink.\n     */\n    error(e = undefined) {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n    error: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let writeAlgorithm = () => promiseResolvedWith(undefined);\n    let closeAlgorithm = () => promiseResolvedWith(undefined);\n    let abortAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSink.start !== undefined) {\n        startAlgorithm = () => underlyingSink.start(controller);\n    }\n    if (underlyingSink.write !== undefined) {\n        writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n    }\n    if (underlyingSink.close !== undefined) {\n        closeAlgorithm = () => underlyingSink.close();\n    }\n    if (underlyingSink.abort !== undefined) {\n        abortAlgorithm = reason => underlyingSink.abort(reason);\n    }\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, closeSentinel, 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    try {\n        EnqueueValueWithSize(controller, chunk, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (!controller._started) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const value = PeekQueueValue(controller);\n    if (value === closeSentinel) {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, value);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    if (writer._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    if (writer._closedPromise_resolve === undefined) {\n        return;\n    }\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    if (writer._readyPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    if (writer._readyPromise_resolve === undefined) {\n        return;\n    }\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch (_a) {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    // eslint-disable-next-line no-shadow\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\n// eslint-disable-next-line no-redeclare\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (!preventAbort) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (!preventCancel) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return newPromise((resolveRead, rejectRead) => {\n                    ReadableStreamDefaultReaderRead(reader, {\n                        _chunkSteps: chunk => {\n                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                            resolveRead(false);\n                        },\n                        _closeSteps: () => resolveRead(true),\n                        _errorSteps: rejectRead\n                    });\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (!preventAbort) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (!preventClose) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('close');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            readRequest._chunkSteps(chunk);\n        }\n        else {\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        }\n    }\n}\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (!controller._closeRequested && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSource.start !== undefined) {\n        startAlgorithm = () => underlyingSource.start(controller);\n    }\n    if (underlyingSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingSource.pull(controller);\n    }\n    if (underlyingSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingSource.cancel(reason);\n    }\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading) {\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readRequest = {\n            _chunkSteps: value => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    reading = false;\n                    const value1 = value;\n                    const value2 = value;\n                    // There is no way to access the cloning code right now in the reference implementation.\n                    // If we add one then we'll need an implementation for serializable objects.\n                    // if (!canceled2 && cloneForBranch2) {\n                    //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n                    // }\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        // do nothing\n    }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n        if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n        }\n    });\n    return [branch1, branch2];\n}\n\nfunction convertUnderlyingDefaultOrByteSource(source, context) {\n    assertDictionary(source, context);\n    const original = source;\n    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n    const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    const pull = original === null || original === void 0 ? void 0 : original.pull;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    return {\n        autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n            undefined :\n            convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n        cancel: cancel === undefined ?\n            undefined :\n            convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n        pull: pull === undefined ?\n            undefined :\n            convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n        type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n    };\n}\nfunction convertUnderlyingSourceCancelCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSourcePullCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSourceStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertReadableStreamType(type, context) {\n    type = `${type}`;\n    if (type !== 'bytes') {\n        throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n    }\n    return type;\n}\n\nfunction convertReaderOptions(options, context) {\n    assertDictionary(options, context);\n    const mode = options === null || options === void 0 ? void 0 : options.mode;\n    return {\n        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n    };\n}\nfunction convertReadableStreamReaderMode(mode, context) {\n    mode = `${mode}`;\n    if (mode !== 'byob') {\n        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n    }\n    return mode;\n}\n\nfunction convertIteratorOptions(options, context) {\n    assertDictionary(options, context);\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    return { preventCancel: Boolean(preventCancel) };\n}\n\nfunction convertPipeOptions(options, context) {\n    assertDictionary(options, context);\n    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal !== undefined) {\n        assertAbortSignal(signal, `${context} has member 'signal' that`);\n    }\n    return {\n        preventAbort: Boolean(preventAbort),\n        preventCancel: Boolean(preventCancel),\n        preventClose: Boolean(preventClose),\n        signal\n    };\n}\nfunction assertAbortSignal(signal, context) {\n    if (!isAbortSignal(signal)) {\n        throw new TypeError(`${context} is not an AbortSignal.`);\n    }\n}\n\nfunction convertReadableWritablePair(pair, context) {\n    assertDictionary(pair, context);\n    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n    assertReadableStream(readable, `${context} has member 'readable' that`);\n    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n    assertWritableStream(writable, `${context} has member 'writable' that`);\n    return { readable, writable };\n}\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nclass ReadableStream {\n    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n        if (rawUnderlyingSource === undefined) {\n            rawUnderlyingSource = null;\n        }\n        else {\n            assertObject(rawUnderlyingSource, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n        InitializeReadableStream(this);\n        if (underlyingSource.type === 'bytes') {\n            if (strategy.size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            const highWaterMark = ExtractHighWaterMark(strategy, 0);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else {\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n    }\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n    get locked() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    /**\n     * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n     *\n     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n     * method, which might or might not use it.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        const options = convertReaderOptions(rawOptions, 'First parameter');\n        if (options.mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this);\n        }\n        return AcquireReadableStreamBYOBReader(this);\n    }\n    pipeThrough(rawTransform, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n        const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n        const options = convertPipeOptions(rawOptions, 'Second parameter');\n        if (IsReadableStreamLocked(this)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(transform.writable)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        setPromiseIsHandledToTrue(promise);\n        return transform.readable;\n    }\n    pipeTo(destination, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (destination === undefined) {\n            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n        }\n        if (!IsWritableStream(destination)) {\n            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n        }\n        let options;\n        try {\n            options = convertPipeOptions(rawOptions, 'Second parameter');\n        }\n        catch (e) {\n            return promiseRejectedWith(e);\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(destination)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n    }\n    /**\n     * Tees this readable stream, returning a two-element array containing the two resulting branches as\n     * new {@link ReadableStream} instances.\n     *\n     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n     * propagated to the stream's underlying source.\n     *\n     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n     * this could allow interference between the two branches.\n     */\n    tee() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return CreateArrayFromList(branches);\n    }\n    values(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('values');\n        }\n        const options = convertIteratorOptions(rawOptions, 'First parameter');\n        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n    }\n}\nObject.defineProperties(ReadableStream.prototype, {\n    cancel: { enumerable: true },\n    getReader: { enumerable: true },\n    pipeThrough: { enumerable: true },\n    pipeTo: { enumerable: true },\n    tee: { enumerable: true },\n    values: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStream',\n        configurable: true\n    });\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.values,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseResolve(reader);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._closeSteps();\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._errorSteps(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._errorSteps(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nfunction convertQueuingStrategyInit(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n    return {\n        highWaterMark: convertUnrestrictedDouble(highWaterMark)\n    };\n}\n\nconst byteLengthSizeFunction = function size(chunk) {\n    return chunk.byteLength;\n};\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nclass ByteLengthQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('highWaterMark');\n        }\n        return this._byteLengthQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by returning the value of its `byteLength` property.\n     */\n    get size() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('size');\n        }\n        return byteLengthSizeFunction;\n    }\n}\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ByteLengthQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the ByteLengthQueuingStrategy.\nfunction byteLengthBrandCheckException(name) {\n    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\nfunction IsByteLengthQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nconst countSizeFunction = function size() {\n    return 1;\n};\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nclass CountQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('highWaterMark');\n        }\n        return this._countQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by always returning 1.\n     * This ensures that the total queue size is a count of the number of chunks in the queue.\n     */\n    get size() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('size');\n        }\n        return countSizeFunction;\n    }\n}\nObject.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'CountQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the CountQueuingStrategy.\nfunction countBrandCheckException(name) {\n    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\nfunction IsCountQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nfunction convertTransformer(original, context) {\n    assertDictionary(original, context);\n    const flush = original === null || original === void 0 ? void 0 : original.flush;\n    const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const transform = original === null || original === void 0 ? void 0 : original.transform;\n    const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n    return {\n        flush: flush === undefined ?\n            undefined :\n            convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n        readableType,\n        start: start === undefined ?\n            undefined :\n            convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n        transform: transform === undefined ?\n            undefined :\n            convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n        writableType\n    };\n}\nfunction convertTransformerFlushCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertTransformerStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertTransformerTransformCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\n// Class TransformStream\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nclass TransformStream {\n    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n        if (rawTransformer === undefined) {\n            rawTransformer = null;\n        }\n        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n        const transformer = convertTransformer(rawTransformer, 'First parameter');\n        if (transformer.readableType !== undefined) {\n            throw new RangeError('Invalid readableType specified');\n        }\n        if (transformer.writableType !== undefined) {\n            throw new RangeError('Invalid writableType specified');\n        }\n        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        if (transformer.start !== undefined) {\n            startPromise_resolve(transformer.start(this._transformStreamController));\n        }\n        else {\n            startPromise_resolve(undefined);\n        }\n    }\n    /**\n     * The readable side of the transform stream.\n     */\n    get readable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('readable');\n        }\n        return this._readable;\n    }\n    /**\n     * The writable side of the transform stream.\n     */\n    get writable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('writable');\n        }\n        return this._writable;\n    }\n}\nObject.defineProperties(TransformStream.prototype, {\n    readable: { enumerable: true },\n    writable: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStream',\n        configurable: true\n    });\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return true;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\n// Class TransformStreamDefaultController\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nclass TransformStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.\n     */\n    get desiredSize() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors both the readable side and the writable side of the controlled transform stream, making all future\n     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n     */\n    error(reason = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    /**\n     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n     * transformer only needs to consume a portion of the chunks written to the writable side.\n     */\n    terminate() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    terminate: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStreamDefaultController',\n        configurable: true\n    });\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    let flushAlgorithm = () => promiseResolvedWith(undefined);\n    if (transformer.transform !== undefined) {\n        transformAlgorithm = chunk => transformer.transform(chunk, controller);\n    }\n    if (transformer.flush !== undefined) {\n        flushAlgorithm = () => transformer.flush(controller);\n    }\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    ReadableStreamDefaultControllerClose(readableController);\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        ReadableStreamDefaultControllerClose(readable._readableStreamController);\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableByteStreamController, ReadableStream, ReadableStreamBYOBReader, ReadableStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, TransformStream, TransformStreamDefaultController, WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter };\n//# sourceMappingURL=ponyfill.es6.mjs.map\n"],"names":["SymbolPolyfill","Symbol","iterator","description","noop","globals","self","window","global","typeIsObject","x","rethrowAssertionErrorRejection","originalPromise","Promise","originalPromiseThen","prototype","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","promiseResolvedWith","value","promiseRejectedWith","reason","PerformPromiseThen","promise","onFulfilled","onRejected","call","uponPromise","undefined","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","queueMicrotask","globalQueueMicrotask","resolvedPromise","fn","reflectCall","F","V","args","TypeError","Function","apply","promiseCall","SimpleQueue","constructor","this","_cursor","_size","_front","_elements","_next","_back","length","push","element","oldBack","newBack","QUEUE_MAX_ARRAY_SIZE","shift","oldFront","newFront","oldCursor","newCursor","elements","forEach","callback","i","node","peek","front","cursor","ReadableStreamReaderGenericInitialize","reader","stream","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseResolve","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","AbortSteps","ErrorSteps","CancelSteps","PullSteps","NumberIsFinite","Number","isFinite","MathTrunc","Math","trunc","v","ceil","floor","assertDictionary","obj","context","assertFunction","assertObject","isObject","assertRequiredArgument","position","assertRequiredField","field","convertUnrestrictedDouble","censorNegativeZero","convertUnsignedLongLongWithEnforceRange","upperBound","MAX_SAFE_INTEGER","integerPart","assertReadableStream","IsReadableStream","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamFulfillReadRequest","chunk","done","_closeSteps","_chunkSteps","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStreamLocked","closed","defaultReaderBrandCheckException","cancel","read","resolvePromise","rejectPromise","ReadableStreamDefaultReaderRead","_errorSteps","e","releaseLock","Object","hasOwnProperty","_disturbed","_readableStreamController","AsyncIteratorPrototype","defineProperties","enumerable","toStringTag","defineProperty","configurable","asyncIterator","ReadableStreamAsyncIteratorImpl","preventCancel","_ongoingPromise","_isFinished","_preventCancel","next","nextSteps","_nextSteps","return","returnSteps","_returnSteps","result","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","_asyncIteratorImpl","streamAsyncIteratorBrandCheckException","setPrototypeOf","NumberIsNaN","isNaN","IsFiniteNonNegativeNumber","IsNonNegativeNumber","Infinity","DequeueValue","container","pair","_queue","_queueTotalSize","size","EnqueueValueWithSize","RangeError","ResetQueue","CreateArrayFromList","slice","ReadableStreamBYOBRequest","view","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","respond","bytesWritten","_associatedReadableByteStreamController","buffer","controller","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","respondWithNewView","ArrayBuffer","isView","byteLength","firstDescriptor","_pendingPullIntos","byteOffset","bytesFilled","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","byobRequest","IsReadableByteStreamController","byteStreamControllerBrandCheckException","_byobRequest","Uint8Array","create","request","SetUpReadableStreamBYOBRequest","desiredSize","ReadableByteStreamControllerGetDesiredSize","close","_closeRequested","state","_controlledReadableByteStream","ReadableByteStreamControllerError","ReadableByteStreamControllerClearAlgorithms","ReadableStreamClose","ReadableByteStreamControllerClose","enqueue","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableStreamHasBYOBReader","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerEnqueue","error","_cancelAlgorithm","entry","ReadableByteStreamControllerHandleQueueDrain","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","viewConstructor","readerType","_started","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerShouldCallPull","_pulling","_pullAgain","_pullAlgorithm","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","readIntoRequest","_readIntoRequests","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","dest","destOffset","src","srcOffset","n","set","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","ReadableByteStreamControllerClearPendingPullIntos","ReadableStreamError","_strategyHWM","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","highWaterMark","startAlgorithm","pullAlgorithm","cancelAlgorithm","start","pull","r","SetUpReadableByteStreamController","ReadableStreamAddReadIntoRequest","IsReadableStreamBYOBReader","ReadableStreamBYOBReader","byobReaderBrandCheckException","DataView","BYTES_PER_ELEMENT","ctor","emptyView","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ExtractHighWaterMark","strategy","defaultHWM","ExtractSizeAlgorithm","convertQueuingStrategy","init","convertQueuingStrategySize","convertUnderlyingSinkAbortCallback","original","convertUnderlyingSinkCloseCallback","convertUnderlyingSinkStartCallback","convertUnderlyingSinkWriteCallback","assertWritableStream","IsWritableStream","WritableStream","rawUnderlyingSink","rawStrategy","underlyingSink","abort","type","write","convertUnderlyingSink","InitializeWritableStream","sizeAlgorithm","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","streamBrandCheckException$2","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","getWriter","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","_promise","wasAlreadyErroring","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","closeSentinel","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDealWithRejection","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","storedError","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseReset","_ownerWritableStream","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_writeAlgorithm","_closeAlgorithm","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","_readyPromise_resolve","_readyPromise_reject","NativeDOMException","DOMException","DOMException$1","_a","isDOMExceptionConstructor","message","Error","captureStackTrace","writable","createDOMExceptionPolyfill","ReadableStreamPipeTo","source","preventClose","preventAbort","signal","shuttingDown","currentWrite","actions","shutdownWithAction","all","map","action","aborted","addEventListener","isOrBecomesErrored","shutdown","WritableStreamDefaultWriterCloseWithErrorPropagation","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","resolveLoop","rejectLoop","resolveRead","rejectRead","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException$1","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","ReadableStreamDefaultControllerShouldCallPull","SetUpReadableStreamDefaultController","convertUnderlyingSourceCancelCallback","convertUnderlyingSourcePullCallback","convertUnderlyingSourceStartCallback","convertReadableStreamType","convertReadableStreamReaderMode","mode","convertPipeOptions","options","isAbortSignal","assertAbortSignal","ReadableStream","rawUnderlyingSource","underlyingSource","convertUnderlyingDefaultOrByteSource","InitializeReadableStream","SetUpReadableStreamDefaultControllerFromUnderlyingSource","streamBrandCheckException$1","getReader","rawOptions","convertReaderOptions","pipeThrough","rawTransform","transform","readable","convertReadableWritablePair","pipeTo","destination","tee","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","canceled1","canceled2","cancelPromise","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","values","impl","AcquireReadableStreamAsyncIterator","convertIteratorOptions","convertQueuingStrategyInit","byteLengthSizeFunction","ByteLengthQueuingStrategy","_byteLengthQueuingStrategyHighWaterMark","IsByteLengthQueuingStrategy","byteLengthBrandCheckException","countSizeFunction","CountQueuingStrategy","_countQueuingStrategyHighWaterMark","IsCountQueuingStrategy","countBrandCheckException","convertTransformerFlushCallback","convertTransformerStartCallback","convertTransformerTransformCallback","TransformStream","rawTransformer","rawWritableStrategy","rawReadableStrategy","writableStrategy","readableStrategy","transformer","flush","readableType","writableType","convertTransformer","readableHighWaterMark","readableSizeAlgorithm","writableHighWaterMark","writableSizeAlgorithm","startPromise_resolve","startPromise","_transformStreamController","_backpressureChangePromise","_writable","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamError","TransformStreamDefaultSinkAbortAlgorithm","_readable","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","CreateWritableStream","_backpressureChangePromise_resolve","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","flushAlgorithm","_controlledTransformStream","_transformAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","IsTransformStream","streamBrandCheckException","IsTransformStreamDefaultController","defaultControllerBrandCheckException","terminate","TransformStreamDefaultControllerTerminate","readableController","ReadableStreamDefaultControllerHasBackpressure"],"mappings":"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"}