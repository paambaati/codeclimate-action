{"version":3,"file":"ponyfill.es6.min.mjs","sources":["../../node_modules/@openpgp/web-stream-tools/node_modules/web-streams-polyfill/dist/ponyfill.es6.mjs"],"sourcesContent":["/**\n * web-streams-polyfill v3.0.3\n */\n/// <reference lib=\"es2015.symbol\" />\nconst SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?\n    Symbol :\n    description => `Symbol(${description})`;\n\n/// <reference lib=\"dom\" />\nfunction noop() {\n    return undefined;\n}\nfunction getGlobals() {\n    if (typeof self !== 'undefined') {\n        return self;\n    }\n    else if (typeof window !== 'undefined') {\n        return window;\n    }\n    else if (typeof global !== 'undefined') {\n        return global;\n    }\n    return undefined;\n}\nconst globals = getGlobals();\n\nfunction typeIsObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nconst rethrowAssertionErrorRejection = noop;\n\nconst originalPromise = Promise;\nconst originalPromiseThen = Promise.prototype.then;\nconst originalPromiseResolve = Promise.resolve.bind(originalPromise);\nconst originalPromiseReject = Promise.reject.bind(originalPromise);\nfunction newPromise(executor) {\n    return new originalPromise(executor);\n}\nfunction promiseResolvedWith(value) {\n    return originalPromiseResolve(value);\n}\nfunction promiseRejectedWith(reason) {\n    return originalPromiseReject(reason);\n}\nfunction PerformPromiseThen(promise, onFulfilled, onRejected) {\n    // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an\n    // approximation.\n    return originalPromiseThen.call(promise, onFulfilled, onRejected);\n}\nfunction uponPromise(promise, onFulfilled, onRejected) {\n    PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);\n}\nfunction uponFulfillment(promise, onFulfilled) {\n    uponPromise(promise, onFulfilled);\n}\nfunction uponRejection(promise, onRejected) {\n    uponPromise(promise, undefined, onRejected);\n}\nfunction transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {\n    return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);\n}\nfunction setPromiseIsHandledToTrue(promise) {\n    PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);\n}\nconst queueMicrotask = (() => {\n    const globalQueueMicrotask = globals && globals.queueMicrotask;\n    if (typeof globalQueueMicrotask === 'function') {\n        return globalQueueMicrotask;\n    }\n    const resolvedPromise = promiseResolvedWith(undefined);\n    return (fn) => PerformPromiseThen(resolvedPromise, fn);\n})();\nfunction reflectCall(F, V, args) {\n    if (typeof F !== 'function') {\n        throw new TypeError('Argument is not a function');\n    }\n    return Function.prototype.apply.call(F, V, args);\n}\nfunction promiseCall(F, V, args) {\n    try {\n        return promiseResolvedWith(reflectCall(F, V, args));\n    }\n    catch (value) {\n        return promiseRejectedWith(value);\n    }\n}\n\n// Original from Chromium\n// https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js\nconst QUEUE_MAX_ARRAY_SIZE = 16384;\n/**\n * Simple queue structure.\n *\n * Avoids scalability issues with using a packed array directly by using\n * multiple arrays in a linked list and keeping the array size bounded.\n */\nclass SimpleQueue {\n    constructor() {\n        this._cursor = 0;\n        this._size = 0;\n        // _front and _back are always defined.\n        this._front = {\n            _elements: [],\n            _next: undefined\n        };\n        this._back = this._front;\n        // The cursor is used to avoid calling Array.shift().\n        // It contains the index of the front element of the array inside the\n        // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).\n        this._cursor = 0;\n        // When there is only one node, size === elements.length - cursor.\n        this._size = 0;\n    }\n    get length() {\n        return this._size;\n    }\n    // For exception safety, this method is structured in order:\n    // 1. Read state\n    // 2. Calculate required state mutations\n    // 3. Perform state mutations\n    push(element) {\n        const oldBack = this._back;\n        let newBack = oldBack;\n        if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {\n            newBack = {\n                _elements: [],\n                _next: undefined\n            };\n        }\n        // push() is the mutation most likely to throw an exception, so it\n        // goes first.\n        oldBack._elements.push(element);\n        if (newBack !== oldBack) {\n            this._back = newBack;\n            oldBack._next = newBack;\n        }\n        ++this._size;\n    }\n    // Like push(), shift() follows the read -> calculate -> mutate pattern for\n    // exception safety.\n    shift() { // must not be called on an empty queue\n        const oldFront = this._front;\n        let newFront = oldFront;\n        const oldCursor = this._cursor;\n        let newCursor = oldCursor + 1;\n        const elements = oldFront._elements;\n        const element = elements[oldCursor];\n        if (newCursor === QUEUE_MAX_ARRAY_SIZE) {\n            newFront = oldFront._next;\n            newCursor = 0;\n        }\n        // No mutations before this point.\n        --this._size;\n        this._cursor = newCursor;\n        if (oldFront !== newFront) {\n            this._front = newFront;\n        }\n        // Permit shifted element to be garbage collected.\n        elements[oldCursor] = undefined;\n        return element;\n    }\n    // The tricky thing about forEach() is that it can be called\n    // re-entrantly. The queue may be mutated inside the callback. It is easy to\n    // see that push() within the callback has no negative effects since the end\n    // of the queue is checked for on every iteration. If shift() is called\n    // repeatedly within the callback then the next iteration may return an\n    // element that has been removed. In this case the callback will be called\n    // with undefined values until we either \"catch up\" with elements that still\n    // exist or reach the back of the queue.\n    forEach(callback) {\n        let i = this._cursor;\n        let node = this._front;\n        let elements = node._elements;\n        while (i !== elements.length || node._next !== undefined) {\n            if (i === elements.length) {\n                node = node._next;\n                elements = node._elements;\n                i = 0;\n                if (elements.length === 0) {\n                    break;\n                }\n            }\n            callback(elements[i]);\n            ++i;\n        }\n    }\n    // Return the element that would be returned if shift() was called now,\n    // without modifying the queue.\n    peek() { // must not be called on an empty queue\n        const front = this._front;\n        const cursor = this._cursor;\n        return front._elements[cursor];\n    }\n}\n\nfunction ReadableStreamReaderGenericInitialize(reader, stream) {\n    reader._ownerReadableStream = stream;\n    stream._reader = reader;\n    if (stream._state === 'readable') {\n        defaultReaderClosedPromiseInitialize(reader);\n    }\n    else if (stream._state === 'closed') {\n        defaultReaderClosedPromiseInitializeAsResolved(reader);\n    }\n    else {\n        defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);\n    }\n}\n// A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state\n// check.\nfunction ReadableStreamReaderGenericCancel(reader, reason) {\n    const stream = reader._ownerReadableStream;\n    return ReadableStreamCancel(stream, reason);\n}\nfunction ReadableStreamReaderGenericRelease(reader) {\n    if (reader._ownerReadableStream._state === 'readable') {\n        defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    else {\n        defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));\n    }\n    reader._ownerReadableStream._reader = undefined;\n    reader._ownerReadableStream = undefined;\n}\n// Helper functions for the readers.\nfunction readerLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released reader');\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderClosedPromiseInitialize(reader) {\n    reader._closedPromise = newPromise((resolve, reject) => {\n        reader._closedPromise_resolve = resolve;\n        reader._closedPromise_reject = reject;\n    });\n}\nfunction defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseReject(reader, reason);\n}\nfunction defaultReaderClosedPromiseInitializeAsResolved(reader) {\n    defaultReaderClosedPromiseInitialize(reader);\n    defaultReaderClosedPromiseResolve(reader);\n}\nfunction defaultReaderClosedPromiseReject(reader, reason) {\n    if (reader._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(reader._closedPromise);\n    reader._closedPromise_reject(reason);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\nfunction defaultReaderClosedPromiseResetToRejected(reader, reason) {\n    defaultReaderClosedPromiseInitializeAsRejected(reader, reason);\n}\nfunction defaultReaderClosedPromiseResolve(reader) {\n    if (reader._closedPromise_resolve === undefined) {\n        return;\n    }\n    reader._closedPromise_resolve(undefined);\n    reader._closedPromise_resolve = undefined;\n    reader._closedPromise_reject = undefined;\n}\n\nconst AbortSteps = SymbolPolyfill('[[AbortSteps]]');\nconst ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');\nconst CancelSteps = SymbolPolyfill('[[CancelSteps]]');\nconst PullSteps = SymbolPolyfill('[[PullSteps]]');\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill\nconst NumberIsFinite = Number.isFinite || function (x) {\n    return typeof x === 'number' && isFinite(x);\n};\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill\nconst MathTrunc = Math.trunc || function (v) {\n    return v < 0 ? Math.ceil(v) : Math.floor(v);\n};\n\n// https://heycam.github.io/webidl/#idl-dictionaries\nfunction isDictionary(x) {\n    return typeof x === 'object' || typeof x === 'function';\n}\nfunction assertDictionary(obj, context) {\n    if (obj !== undefined && !isDictionary(obj)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-callback-functions\nfunction assertFunction(x, context) {\n    if (typeof x !== 'function') {\n        throw new TypeError(`${context} is not a function.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-object\nfunction isObject(x) {\n    return (typeof x === 'object' && x !== null) || typeof x === 'function';\n}\nfunction assertObject(x, context) {\n    if (!isObject(x)) {\n        throw new TypeError(`${context} is not an object.`);\n    }\n}\nfunction assertRequiredArgument(x, position, context) {\n    if (x === undefined) {\n        throw new TypeError(`Parameter ${position} is required in '${context}'.`);\n    }\n}\nfunction assertRequiredField(x, field, context) {\n    if (x === undefined) {\n        throw new TypeError(`${field} is required in '${context}'.`);\n    }\n}\n// https://heycam.github.io/webidl/#idl-unrestricted-double\nfunction convertUnrestrictedDouble(value) {\n    return Number(value);\n}\nfunction censorNegativeZero(x) {\n    return x === 0 ? 0 : x;\n}\nfunction integerPart(x) {\n    return censorNegativeZero(MathTrunc(x));\n}\n// https://heycam.github.io/webidl/#idl-unsigned-long-long\nfunction convertUnsignedLongLongWithEnforceRange(value, context) {\n    const lowerBound = 0;\n    const upperBound = Number.MAX_SAFE_INTEGER;\n    let x = Number(value);\n    x = censorNegativeZero(x);\n    if (!NumberIsFinite(x)) {\n        throw new TypeError(`${context} is not a finite number`);\n    }\n    x = integerPart(x);\n    if (x < lowerBound || x > upperBound) {\n        throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);\n    }\n    if (!NumberIsFinite(x) || x === 0) {\n        return 0;\n    }\n    // TODO Use BigInt if supported?\n    // let xBigInt = BigInt(integerPart(x));\n    // xBigInt = BigInt.asUintN(64, xBigInt);\n    // return Number(xBigInt);\n    return x;\n}\n\nfunction assertReadableStream(x, context) {\n    if (!IsReadableStream(x)) {\n        throw new TypeError(`${context} is not a ReadableStream.`);\n    }\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamDefaultReader(stream) {\n    return new ReadableStreamDefaultReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadRequest(stream, readRequest) {\n    stream._reader._readRequests.push(readRequest);\n}\nfunction ReadableStreamFulfillReadRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readRequest = reader._readRequests.shift();\n    if (done) {\n        readRequest._closeSteps();\n    }\n    else {\n        readRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadRequests(stream) {\n    return stream._reader._readRequests.length;\n}\nfunction ReadableStreamHasDefaultReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamDefaultReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A default reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamDefaultReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed,\n     * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            return promiseRejectedWith(defaultReaderBrandCheckException('read'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: () => resolvePromise({ value: undefined, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamDefaultReaderRead(this, readRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamDefaultReader(this)) {\n            throw defaultReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamDefaultReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamDefaultReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultReaderRead(reader, readRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        readRequest._closeSteps();\n    }\n    else if (stream._state === 'errored') {\n        readRequest._errorSteps(stream._storedError);\n    }\n    else {\n        stream._readableStreamController[PullSteps](readRequest);\n    }\n}\n// Helper functions for the ReadableStreamDefaultReader.\nfunction defaultReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nlet AsyncIteratorPrototype;\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    // We're running inside a ES2018+ environment, but we're compiling to an older syntax.\n    // We cannot access %AsyncIteratorPrototype% without non-ES2018 syntax, but we can re-create it.\n    AsyncIteratorPrototype = {\n        // 25.1.3.1 %AsyncIteratorPrototype% [ @@asyncIterator ] ( )\n        // https://tc39.github.io/ecma262/#sec-asynciteratorprototype-asynciterator\n        [SymbolPolyfill.asyncIterator]() {\n            return this;\n        }\n    };\n    Object.defineProperty(AsyncIteratorPrototype, SymbolPolyfill.asyncIterator, { enumerable: false });\n}\n\n/// <reference lib=\"es2018.asynciterable\" />\nclass ReadableStreamAsyncIteratorImpl {\n    constructor(reader, preventCancel) {\n        this._ongoingPromise = undefined;\n        this._isFinished = false;\n        this._reader = reader;\n        this._preventCancel = preventCancel;\n    }\n    next() {\n        const nextSteps = () => this._nextSteps();\n        this._ongoingPromise = this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :\n            nextSteps();\n        return this._ongoingPromise;\n    }\n    return(value) {\n        const returnSteps = () => this._returnSteps(value);\n        return this._ongoingPromise ?\n            transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :\n            returnSteps();\n    }\n    _nextSteps() {\n        if (this._isFinished) {\n            return Promise.resolve({ value: undefined, done: true });\n        }\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('iterate'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readRequest = {\n            _chunkSteps: chunk => {\n                this._ongoingPromise = undefined;\n                // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.\n                // FIXME Is this a bug in the specification, or in the test?\n                queueMicrotask(() => resolvePromise({ value: chunk, done: false }));\n            },\n            _closeSteps: () => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                resolvePromise({ value: undefined, done: true });\n            },\n            _errorSteps: reason => {\n                this._ongoingPromise = undefined;\n                this._isFinished = true;\n                ReadableStreamReaderGenericRelease(reader);\n                rejectPromise(reason);\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promise;\n    }\n    _returnSteps(value) {\n        if (this._isFinished) {\n            return Promise.resolve({ value, done: true });\n        }\n        this._isFinished = true;\n        const reader = this._reader;\n        if (reader._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('finish iterating'));\n        }\n        if (!this._preventCancel) {\n            const result = ReadableStreamReaderGenericCancel(reader, value);\n            ReadableStreamReaderGenericRelease(reader);\n            return transformPromiseWith(result, () => ({ value, done: true }));\n        }\n        ReadableStreamReaderGenericRelease(reader);\n        return promiseResolvedWith({ value, done: true });\n    }\n}\nconst ReadableStreamAsyncIteratorPrototype = {\n    next() {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));\n        }\n        return this._asyncIteratorImpl.next();\n    },\n    return(value) {\n        if (!IsReadableStreamAsyncIterator(this)) {\n            return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));\n        }\n        return this._asyncIteratorImpl.return(value);\n    }\n};\nif (AsyncIteratorPrototype !== undefined) {\n    Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);\n}\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamAsyncIterator(stream, preventCancel) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);\n    const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);\n    iterator._asyncIteratorImpl = impl;\n    return iterator;\n}\nfunction IsReadableStreamAsyncIterator(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {\n        return false;\n    }\n    return true;\n}\n// Helper functions for the ReadableStream.\nfunction streamAsyncIteratorBrandCheckException(name) {\n    return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);\n}\n\n/// <reference lib=\"es2015.core\" />\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill\nconst NumberIsNaN = Number.isNaN || function (x) {\n    // eslint-disable-next-line no-self-compare\n    return x !== x;\n};\n\nfunction IsFiniteNonNegativeNumber(v) {\n    if (!IsNonNegativeNumber(v)) {\n        return false;\n    }\n    if (v === Infinity) {\n        return false;\n    }\n    return true;\n}\nfunction IsNonNegativeNumber(v) {\n    if (typeof v !== 'number') {\n        return false;\n    }\n    if (NumberIsNaN(v)) {\n        return false;\n    }\n    if (v < 0) {\n        return false;\n    }\n    return true;\n}\n\nfunction DequeueValue(container) {\n    const pair = container._queue.shift();\n    container._queueTotalSize -= pair.size;\n    if (container._queueTotalSize < 0) {\n        container._queueTotalSize = 0;\n    }\n    return pair.value;\n}\nfunction EnqueueValueWithSize(container, value, size) {\n    size = Number(size);\n    if (!IsFiniteNonNegativeNumber(size)) {\n        throw new RangeError('Size must be a finite, non-NaN, non-negative number.');\n    }\n    container._queue.push({ value, size });\n    container._queueTotalSize += size;\n}\nfunction PeekQueueValue(container) {\n    const pair = container._queue.peek();\n    return pair.value;\n}\nfunction ResetQueue(container) {\n    container._queue = new SimpleQueue();\n    container._queueTotalSize = 0;\n}\n\nfunction CreateArrayFromList(elements) {\n    // We use arrays to represent lists, so this is basically a no-op.\n    // Do a slice though just in case we happen to depend on the unique-ness.\n    return elements.slice();\n}\nfunction CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {\n    new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);\n}\n// Not implemented correctly\nfunction TransferArrayBuffer(O) {\n    return O;\n}\n// Not implemented correctly\nfunction IsDetachedBuffer(O) {\n    return false;\n}\n\n/**\n * A pull-into request in a {@link ReadableByteStreamController}.\n *\n * @public\n */\nclass ReadableStreamBYOBRequest {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.\n     */\n    get view() {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('view');\n        }\n        return this._view;\n    }\n    respond(bytesWritten) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respond');\n        }\n        assertRequiredArgument(bytesWritten, 1, 'respond');\n        bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        if (IsDetachedBuffer(this._view.buffer)) ;\n        ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);\n    }\n    respondWithNewView(view) {\n        if (!IsReadableStreamBYOBRequest(this)) {\n            throw byobRequestBrandCheckException('respondWithNewView');\n        }\n        assertRequiredArgument(view, 1, 'respondWithNewView');\n        if (!ArrayBuffer.isView(view)) {\n            throw new TypeError('You can only respond with array buffer views');\n        }\n        if (view.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (view.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._associatedReadableByteStreamController === undefined) {\n            throw new TypeError('This BYOB request has been invalidated');\n        }\n        ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBRequest.prototype, {\n    respond: { enumerable: true },\n    respondWithNewView: { enumerable: true },\n    view: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBRequest',\n        configurable: true\n    });\n}\n/**\n * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableByteStreamController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the current BYOB pull request, or `null` if there isn't one.\n     */\n    get byobRequest() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('byobRequest');\n        }\n        if (this._byobRequest === null && this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);\n            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);\n            SetUpReadableStreamBYOBRequest(byobRequest, this, view);\n            this._byobRequest = byobRequest;\n        }\n        return this._byobRequest;\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('desiredSize');\n        }\n        return ReadableByteStreamControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('close');\n        }\n        if (this._closeRequested) {\n            throw new TypeError('The stream has already been closed; do not close it again!');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);\n        }\n        ReadableByteStreamControllerClose(this);\n    }\n    enqueue(chunk) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('enqueue');\n        }\n        assertRequiredArgument(chunk, 1, 'enqueue');\n        if (!ArrayBuffer.isView(chunk)) {\n            throw new TypeError('chunk must be an array buffer view');\n        }\n        if (chunk.byteLength === 0) {\n            throw new TypeError('chunk must have non-zero byteLength');\n        }\n        if (chunk.buffer.byteLength === 0) {\n            throw new TypeError(`chunk's buffer must have non-zero byteLength`);\n        }\n        if (this._closeRequested) {\n            throw new TypeError('stream is closed or draining');\n        }\n        const state = this._controlledReadableByteStream._state;\n        if (state !== 'readable') {\n            throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);\n        }\n        ReadableByteStreamControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableByteStreamController(this)) {\n            throw byteStreamControllerBrandCheckException('error');\n        }\n        ReadableByteStreamControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        if (this._pendingPullIntos.length > 0) {\n            const firstDescriptor = this._pendingPullIntos.peek();\n            firstDescriptor.bytesFilled = 0;\n        }\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableByteStreamControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableByteStream;\n        if (this._queueTotalSize > 0) {\n            const entry = this._queue.shift();\n            this._queueTotalSize -= entry.byteLength;\n            ReadableByteStreamControllerHandleQueueDrain(this);\n            const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);\n            readRequest._chunkSteps(view);\n            return;\n        }\n        const autoAllocateChunkSize = this._autoAllocateChunkSize;\n        if (autoAllocateChunkSize !== undefined) {\n            let buffer;\n            try {\n                buffer = new ArrayBuffer(autoAllocateChunkSize);\n            }\n            catch (bufferE) {\n                readRequest._errorSteps(bufferE);\n                return;\n            }\n            const pullIntoDescriptor = {\n                buffer,\n                byteOffset: 0,\n                byteLength: autoAllocateChunkSize,\n                bytesFilled: 0,\n                elementSize: 1,\n                viewConstructor: Uint8Array,\n                readerType: 'default'\n            };\n            this._pendingPullIntos.push(pullIntoDescriptor);\n        }\n        ReadableStreamAddReadRequest(stream, readRequest);\n        ReadableByteStreamControllerCallPullIfNeeded(this);\n    }\n}\nObject.defineProperties(ReadableByteStreamController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    byobRequest: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableByteStreamController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableByteStreamController.\nfunction IsReadableByteStreamController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamBYOBRequest(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableByteStreamControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    // TODO: Test controller argument\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableByteStreamControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableByteStreamControllerError(controller, e);\n    });\n}\nfunction ReadableByteStreamControllerClearPendingPullIntos(controller) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    controller._pendingPullIntos = new SimpleQueue();\n}\nfunction ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {\n    let done = false;\n    if (stream._state === 'closed') {\n        done = true;\n    }\n    const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n    if (pullIntoDescriptor.readerType === 'default') {\n        ReadableStreamFulfillReadRequest(stream, filledView, done);\n    }\n    else {\n        ReadableStreamFulfillReadIntoRequest(stream, filledView, done);\n    }\n}\nfunction ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {\n    const bytesFilled = pullIntoDescriptor.bytesFilled;\n    const elementSize = pullIntoDescriptor.elementSize;\n    return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);\n}\nfunction ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {\n    controller._queue.push({ buffer, byteOffset, byteLength });\n    controller._queueTotalSize += byteLength;\n}\nfunction ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {\n    const elementSize = pullIntoDescriptor.elementSize;\n    const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;\n    const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);\n    const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;\n    const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;\n    let totalBytesToCopyRemaining = maxBytesToCopy;\n    let ready = false;\n    if (maxAlignedBytes > currentAlignedBytes) {\n        totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;\n        ready = true;\n    }\n    const queue = controller._queue;\n    while (totalBytesToCopyRemaining > 0) {\n        const headOfQueue = queue.peek();\n        const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);\n        const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);\n        if (headOfQueue.byteLength === bytesToCopy) {\n            queue.shift();\n        }\n        else {\n            headOfQueue.byteOffset += bytesToCopy;\n            headOfQueue.byteLength -= bytesToCopy;\n        }\n        controller._queueTotalSize -= bytesToCopy;\n        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);\n        totalBytesToCopyRemaining -= bytesToCopy;\n    }\n    return ready;\n}\nfunction ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    pullIntoDescriptor.bytesFilled += size;\n}\nfunction ReadableByteStreamControllerHandleQueueDrain(controller) {\n    if (controller._queueTotalSize === 0 && controller._closeRequested) {\n        ReadableByteStreamControllerClearAlgorithms(controller);\n        ReadableStreamClose(controller._controlledReadableByteStream);\n    }\n    else {\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }\n}\nfunction ReadableByteStreamControllerInvalidateBYOBRequest(controller) {\n    if (controller._byobRequest === null) {\n        return;\n    }\n    controller._byobRequest._associatedReadableByteStreamController = undefined;\n    controller._byobRequest._view = null;\n    controller._byobRequest = null;\n}\nfunction ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {\n    while (controller._pendingPullIntos.length > 0) {\n        if (controller._queueTotalSize === 0) {\n            return;\n        }\n        const pullIntoDescriptor = controller._pendingPullIntos.peek();\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {\n    const stream = controller._controlledReadableByteStream;\n    let elementSize = 1;\n    if (view.constructor !== DataView) {\n        elementSize = view.constructor.BYTES_PER_ELEMENT;\n    }\n    const ctor = view.constructor;\n    const buffer = TransferArrayBuffer(view.buffer);\n    const pullIntoDescriptor = {\n        buffer,\n        byteOffset: view.byteOffset,\n        byteLength: view.byteLength,\n        bytesFilled: 0,\n        elementSize,\n        viewConstructor: ctor,\n        readerType: 'byob'\n    };\n    if (controller._pendingPullIntos.length > 0) {\n        controller._pendingPullIntos.push(pullIntoDescriptor);\n        // No ReadableByteStreamControllerCallPullIfNeeded() call since:\n        // - No change happens on desiredSize\n        // - The source has already been notified of that there's at least 1 pending read(view)\n        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n        return;\n    }\n    if (stream._state === 'closed') {\n        const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);\n        readIntoRequest._closeSteps(emptyView);\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {\n            const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);\n            ReadableByteStreamControllerHandleQueueDrain(controller);\n            readIntoRequest._chunkSteps(filledView);\n            return;\n        }\n        if (controller._closeRequested) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            readIntoRequest._errorSteps(e);\n            return;\n        }\n    }\n    controller._pendingPullIntos.push(pullIntoDescriptor);\n    ReadableStreamAddReadIntoRequest(stream, readIntoRequest);\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {\n    firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);\n    const stream = controller._controlledReadableByteStream;\n    if (ReadableStreamHasBYOBReader(stream)) {\n        while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n            const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);\n            ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);\n        }\n    }\n}\nfunction ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {\n    if (pullIntoDescriptor.bytesFilled + bytesWritten > pullIntoDescriptor.byteLength) {\n        throw new RangeError('bytesWritten out of range');\n    }\n    ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);\n    if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {\n        // TODO: Figure out whether we should detach the buffer or not here.\n        return;\n    }\n    ReadableByteStreamControllerShiftPendingPullInto(controller);\n    const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;\n    if (remainderSize > 0) {\n        const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;\n        const remainder = pullIntoDescriptor.buffer.slice(end - remainderSize, end);\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);\n    }\n    pullIntoDescriptor.buffer = TransferArrayBuffer(pullIntoDescriptor.buffer);\n    pullIntoDescriptor.bytesFilled -= remainderSize;\n    ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);\n    ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n}\nfunction ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'closed') {\n        if (bytesWritten !== 0) {\n            throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');\n        }\n        ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor);\n    }\n    else {\n        ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerShiftPendingPullInto(controller) {\n    const descriptor = controller._pendingPullIntos.shift();\n    ReadableByteStreamControllerInvalidateBYOBRequest(controller);\n    return descriptor;\n}\nfunction ReadableByteStreamControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return false;\n    }\n    if (controller._closeRequested) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableByteStreamControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n}\n// A client of ReadableByteStreamController may use these functions directly to bypass state check.\nfunction ReadableByteStreamControllerClose(controller) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    if (controller._queueTotalSize > 0) {\n        controller._closeRequested = true;\n        return;\n    }\n    if (controller._pendingPullIntos.length > 0) {\n        const firstPendingPullInto = controller._pendingPullIntos.peek();\n        if (firstPendingPullInto.bytesFilled > 0) {\n            const e = new TypeError('Insufficient bytes to fill elements in the given buffer');\n            ReadableByteStreamControllerError(controller, e);\n            throw e;\n        }\n    }\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamClose(stream);\n}\nfunction ReadableByteStreamControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledReadableByteStream;\n    if (controller._closeRequested || stream._state !== 'readable') {\n        return;\n    }\n    const buffer = chunk.buffer;\n    const byteOffset = chunk.byteOffset;\n    const byteLength = chunk.byteLength;\n    const transferredBuffer = TransferArrayBuffer(buffer);\n    if (ReadableStreamHasDefaultReader(stream)) {\n        if (ReadableStreamGetNumReadRequests(stream) === 0) {\n            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        }\n        else {\n            const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);\n            ReadableStreamFulfillReadRequest(stream, transferredView, false);\n        }\n    }\n    else if (ReadableStreamHasBYOBReader(stream)) {\n        // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);\n    }\n    else {\n        ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);\n    }\n    ReadableByteStreamControllerCallPullIfNeeded(controller);\n}\nfunction ReadableByteStreamControllerError(controller, e) {\n    const stream = controller._controlledReadableByteStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ReadableByteStreamControllerClearPendingPullIntos(controller);\n    ResetQueue(controller);\n    ReadableByteStreamControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableByteStreamControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableByteStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction ReadableByteStreamControllerRespond(controller, bytesWritten) {\n    bytesWritten = Number(bytesWritten);\n    if (!IsFiniteNonNegativeNumber(bytesWritten)) {\n        throw new RangeError('bytesWritten must be a finite');\n    }\n    ReadableByteStreamControllerRespondInternal(controller, bytesWritten);\n}\nfunction ReadableByteStreamControllerRespondWithNewView(controller, view) {\n    const firstDescriptor = controller._pendingPullIntos.peek();\n    if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {\n        throw new RangeError('The region specified by view does not match byobRequest');\n    }\n    if (firstDescriptor.byteLength !== view.byteLength) {\n        throw new RangeError('The buffer of view has different capacity than byobRequest');\n    }\n    firstDescriptor.buffer = view.buffer;\n    ReadableByteStreamControllerRespondInternal(controller, view.byteLength);\n}\nfunction SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {\n    controller._controlledReadableByteStream = stream;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._byobRequest = null;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._closeRequested = false;\n    controller._started = false;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    controller._autoAllocateChunkSize = autoAllocateChunkSize;\n    controller._pendingPullIntos = new SimpleQueue();\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableByteStreamControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableByteStreamControllerError(controller, r);\n    });\n}\nfunction SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {\n    const controller = Object.create(ReadableByteStreamController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingByteSource.start !== undefined) {\n        startAlgorithm = () => underlyingByteSource.start(controller);\n    }\n    if (underlyingByteSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingByteSource.pull(controller);\n    }\n    if (underlyingByteSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingByteSource.cancel(reason);\n    }\n    const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;\n    if (autoAllocateChunkSize === 0) {\n        throw new TypeError('autoAllocateChunkSize must be greater than 0');\n    }\n    SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);\n}\nfunction SetUpReadableStreamBYOBRequest(request, controller, view) {\n    request._associatedReadableByteStreamController = controller;\n    request._view = view;\n}\n// Helper functions for the ReadableStreamBYOBRequest.\nfunction byobRequestBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);\n}\n// Helper functions for the ReadableByteStreamController.\nfunction byteStreamControllerBrandCheckException(name) {\n    return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);\n}\n\n// Abstract operations for the ReadableStream.\nfunction AcquireReadableStreamBYOBReader(stream) {\n    return new ReadableStreamBYOBReader(stream);\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {\n    stream._reader._readIntoRequests.push(readIntoRequest);\n}\nfunction ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {\n    const reader = stream._reader;\n    const readIntoRequest = reader._readIntoRequests.shift();\n    if (done) {\n        readIntoRequest._closeSteps(chunk);\n    }\n    else {\n        readIntoRequest._chunkSteps(chunk);\n    }\n}\nfunction ReadableStreamGetNumReadIntoRequests(stream) {\n    return stream._reader._readIntoRequests.length;\n}\nfunction ReadableStreamHasBYOBReader(stream) {\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return false;\n    }\n    if (!IsReadableStreamBYOBReader(reader)) {\n        return false;\n    }\n    return true;\n}\n/**\n * A BYOB reader vended by a {@link ReadableStream}.\n *\n * @public\n */\nclass ReadableStreamBYOBReader {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');\n        assertReadableStream(stream, 'First parameter');\n        if (IsReadableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive reading by another reader');\n        }\n        if (!IsReadableByteStreamController(stream._readableStreamController)) {\n            throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +\n                'source');\n        }\n        ReadableStreamReaderGenericInitialize(this, stream);\n        this._readIntoRequests = new SimpleQueue();\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the reader's lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('cancel'));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('cancel'));\n        }\n        return ReadableStreamReaderGenericCancel(this, reason);\n    }\n    /**\n     * Attempts to reads bytes into view, and returns a promise resolved with the result.\n     *\n     * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.\n     */\n    read(view) {\n        if (!IsReadableStreamBYOBReader(this)) {\n            return promiseRejectedWith(byobReaderBrandCheckException('read'));\n        }\n        if (!ArrayBuffer.isView(view)) {\n            return promiseRejectedWith(new TypeError('view must be an array buffer view'));\n        }\n        if (view.byteLength === 0) {\n            return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));\n        }\n        if (view.buffer.byteLength === 0) {\n            return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));\n        }\n        if (this._ownerReadableStream === undefined) {\n            return promiseRejectedWith(readerLockException('read from'));\n        }\n        let resolvePromise;\n        let rejectPromise;\n        const promise = newPromise((resolve, reject) => {\n            resolvePromise = resolve;\n            rejectPromise = reject;\n        });\n        const readIntoRequest = {\n            _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),\n            _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),\n            _errorSteps: e => rejectPromise(e)\n        };\n        ReadableStreamBYOBReaderRead(this, view, readIntoRequest);\n        return promise;\n    }\n    /**\n     * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.\n     * If the associated stream is errored when the lock is released, the reader will appear errored in the same way\n     * from now on; otherwise, the reader will appear closed.\n     *\n     * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by\n     * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to\n     * do so will throw a `TypeError` and leave the reader locked to the stream.\n     */\n    releaseLock() {\n        if (!IsReadableStreamBYOBReader(this)) {\n            throw byobReaderBrandCheckException('releaseLock');\n        }\n        if (this._ownerReadableStream === undefined) {\n            return;\n        }\n        if (this._readIntoRequests.length > 0) {\n            throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');\n        }\n        ReadableStreamReaderGenericRelease(this);\n    }\n}\nObject.defineProperties(ReadableStreamBYOBReader.prototype, {\n    cancel: { enumerable: true },\n    read: { enumerable: true },\n    releaseLock: { enumerable: true },\n    closed: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamBYOBReader',\n        configurable: true\n    });\n}\n// Abstract operations for the readers.\nfunction IsReadableStreamBYOBReader(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {\n    const stream = reader._ownerReadableStream;\n    stream._disturbed = true;\n    if (stream._state === 'errored') {\n        readIntoRequest._errorSteps(stream._storedError);\n    }\n    else {\n        ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);\n    }\n}\n// Helper functions for the ReadableStreamBYOBReader.\nfunction byobReaderBrandCheckException(name) {\n    return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);\n}\n\nfunction ExtractHighWaterMark(strategy, defaultHWM) {\n    const { highWaterMark } = strategy;\n    if (highWaterMark === undefined) {\n        return defaultHWM;\n    }\n    if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {\n        throw new RangeError('Invalid highWaterMark');\n    }\n    return highWaterMark;\n}\nfunction ExtractSizeAlgorithm(strategy) {\n    const { size } = strategy;\n    if (!size) {\n        return () => 1;\n    }\n    return size;\n}\n\nfunction convertQueuingStrategy(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    const size = init === null || init === void 0 ? void 0 : init.size;\n    return {\n        highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),\n        size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)\n    };\n}\nfunction convertQueuingStrategySize(fn, context) {\n    assertFunction(fn, context);\n    return chunk => convertUnrestrictedDouble(fn(chunk));\n}\n\nfunction convertUnderlyingSink(original, context) {\n    assertDictionary(original, context);\n    const abort = original === null || original === void 0 ? void 0 : original.abort;\n    const close = original === null || original === void 0 ? void 0 : original.close;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    const write = original === null || original === void 0 ? void 0 : original.write;\n    return {\n        abort: abort === undefined ?\n            undefined :\n            convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),\n        close: close === undefined ?\n            undefined :\n            convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),\n        write: write === undefined ?\n            undefined :\n            convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),\n        type\n    };\n}\nfunction convertUnderlyingSinkAbortCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSinkCloseCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return () => promiseCall(fn, original, []);\n}\nfunction convertUnderlyingSinkStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSinkWriteCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\nfunction assertWritableStream(x, context) {\n    if (!IsWritableStream(x)) {\n        throw new TypeError(`${context} is not a WritableStream.`);\n    }\n}\n\n/**\n * A writable stream represents a destination for data, into which you can write.\n *\n * @public\n */\nclass WritableStream {\n    constructor(rawUnderlyingSink = {}, rawStrategy = {}) {\n        if (rawUnderlyingSink === undefined) {\n            rawUnderlyingSink = null;\n        }\n        else {\n            assertObject(rawUnderlyingSink, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');\n        InitializeWritableStream(this);\n        const type = underlyingSink.type;\n        if (type !== undefined) {\n            throw new RangeError('Invalid type is specified');\n        }\n        const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n        const highWaterMark = ExtractHighWaterMark(strategy, 1);\n        SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);\n    }\n    /**\n     * Returns whether or not the writable stream is locked to a writer.\n     */\n    get locked() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('locked');\n        }\n        return IsWritableStreamLocked(this);\n    }\n    /**\n     * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be\n     * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort\n     * mechanism of the underlying sink.\n     *\n     * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled\n     * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel\n     * the stream) if the stream is currently locked.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('abort'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));\n        }\n        return WritableStreamAbort(this, reason);\n    }\n    /**\n     * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its\n     * close behavior. During this time any further attempts to write will fail (without erroring the stream).\n     *\n     * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream\n     * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with\n     * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.\n     */\n    close() {\n        if (!IsWritableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$2('close'));\n        }\n        if (IsWritableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(this)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamClose(this);\n    }\n    /**\n     * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream\n     * is locked, no other writer can be acquired until this one is released.\n     *\n     * This functionality is especially useful for creating abstractions that desire the ability to write to a stream\n     * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at\n     * the same time, which would cause the resulting written data to be unpredictable and probably useless.\n     */\n    getWriter() {\n        if (!IsWritableStream(this)) {\n            throw streamBrandCheckException$2('getWriter');\n        }\n        return AcquireWritableStreamDefaultWriter(this);\n    }\n}\nObject.defineProperties(WritableStream.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    getWriter: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStream',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStream.\nfunction AcquireWritableStreamDefaultWriter(stream) {\n    return new WritableStreamDefaultWriter(stream);\n}\n// Throws if and only if startAlgorithm throws.\nfunction CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(WritableStream.prototype);\n    InitializeWritableStream(stream);\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeWritableStream(stream) {\n    stream._state = 'writable';\n    // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is\n    // 'erroring' or 'errored'. May be set to an undefined value.\n    stream._storedError = undefined;\n    stream._writer = undefined;\n    // Initialize to undefined first because the constructor of the controller checks this\n    // variable to validate the caller.\n    stream._writableStreamController = undefined;\n    // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data\n    // producer without waiting for the queued writes to finish.\n    stream._writeRequests = new SimpleQueue();\n    // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents\n    // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.\n    stream._inFlightWriteRequest = undefined;\n    // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer\n    // has been detached.\n    stream._closeRequest = undefined;\n    // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it\n    // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.\n    stream._inFlightCloseRequest = undefined;\n    // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.\n    stream._pendingAbortRequest = undefined;\n    // The backpressure signal set by the controller.\n    stream._backpressure = false;\n}\nfunction IsWritableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsWritableStreamLocked(stream) {\n    if (stream._writer === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamAbort(stream, reason) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._pendingAbortRequest !== undefined) {\n        return stream._pendingAbortRequest._promise;\n    }\n    let wasAlreadyErroring = false;\n    if (state === 'erroring') {\n        wasAlreadyErroring = true;\n        // reason will not be used, so don't keep a reference to it.\n        reason = undefined;\n    }\n    const promise = newPromise((resolve, reject) => {\n        stream._pendingAbortRequest = {\n            _promise: undefined,\n            _resolve: resolve,\n            _reject: reject,\n            _reason: reason,\n            _wasAlreadyErroring: wasAlreadyErroring\n        };\n    });\n    stream._pendingAbortRequest._promise = promise;\n    if (!wasAlreadyErroring) {\n        WritableStreamStartErroring(stream, reason);\n    }\n    return promise;\n}\nfunction WritableStreamClose(stream) {\n    const state = stream._state;\n    if (state === 'closed' || state === 'errored') {\n        return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));\n    }\n    const promise = newPromise((resolve, reject) => {\n        const closeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._closeRequest = closeRequest;\n    });\n    const writer = stream._writer;\n    if (writer !== undefined && stream._backpressure && state === 'writable') {\n        defaultWriterReadyPromiseResolve(writer);\n    }\n    WritableStreamDefaultControllerClose(stream._writableStreamController);\n    return promise;\n}\n// WritableStream API exposed for controllers.\nfunction WritableStreamAddWriteRequest(stream) {\n    const promise = newPromise((resolve, reject) => {\n        const writeRequest = {\n            _resolve: resolve,\n            _reject: reject\n        };\n        stream._writeRequests.push(writeRequest);\n    });\n    return promise;\n}\nfunction WritableStreamDealWithRejection(stream, error) {\n    const state = stream._state;\n    if (state === 'writable') {\n        WritableStreamStartErroring(stream, error);\n        return;\n    }\n    WritableStreamFinishErroring(stream);\n}\nfunction WritableStreamStartErroring(stream, reason) {\n    const controller = stream._writableStreamController;\n    stream._state = 'erroring';\n    stream._storedError = reason;\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);\n    }\n    if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {\n        WritableStreamFinishErroring(stream);\n    }\n}\nfunction WritableStreamFinishErroring(stream) {\n    stream._state = 'errored';\n    stream._writableStreamController[ErrorSteps]();\n    const storedError = stream._storedError;\n    stream._writeRequests.forEach(writeRequest => {\n        writeRequest._reject(storedError);\n    });\n    stream._writeRequests = new SimpleQueue();\n    if (stream._pendingAbortRequest === undefined) {\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const abortRequest = stream._pendingAbortRequest;\n    stream._pendingAbortRequest = undefined;\n    if (abortRequest._wasAlreadyErroring) {\n        abortRequest._reject(storedError);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n        return;\n    }\n    const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);\n    uponPromise(promise, () => {\n        abortRequest._resolve();\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    }, (reason) => {\n        abortRequest._reject(reason);\n        WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);\n    });\n}\nfunction WritableStreamFinishInFlightWrite(stream) {\n    stream._inFlightWriteRequest._resolve(undefined);\n    stream._inFlightWriteRequest = undefined;\n}\nfunction WritableStreamFinishInFlightWriteWithError(stream, error) {\n    stream._inFlightWriteRequest._reject(error);\n    stream._inFlightWriteRequest = undefined;\n    WritableStreamDealWithRejection(stream, error);\n}\nfunction WritableStreamFinishInFlightClose(stream) {\n    stream._inFlightCloseRequest._resolve(undefined);\n    stream._inFlightCloseRequest = undefined;\n    const state = stream._state;\n    if (state === 'erroring') {\n        // The error was too late to do anything, so it is ignored.\n        stream._storedError = undefined;\n        if (stream._pendingAbortRequest !== undefined) {\n            stream._pendingAbortRequest._resolve();\n            stream._pendingAbortRequest = undefined;\n        }\n    }\n    stream._state = 'closed';\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseResolve(writer);\n    }\n}\nfunction WritableStreamFinishInFlightCloseWithError(stream, error) {\n    stream._inFlightCloseRequest._reject(error);\n    stream._inFlightCloseRequest = undefined;\n    // Never execute sink abort() after sink close().\n    if (stream._pendingAbortRequest !== undefined) {\n        stream._pendingAbortRequest._reject(error);\n        stream._pendingAbortRequest = undefined;\n    }\n    WritableStreamDealWithRejection(stream, error);\n}\n// TODO(ricea): Fix alphabetical order.\nfunction WritableStreamCloseQueuedOrInFlight(stream) {\n    if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamHasOperationMarkedInFlight(stream) {\n    if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {\n        return false;\n    }\n    return true;\n}\nfunction WritableStreamMarkCloseRequestInFlight(stream) {\n    stream._inFlightCloseRequest = stream._closeRequest;\n    stream._closeRequest = undefined;\n}\nfunction WritableStreamMarkFirstWriteRequestInFlight(stream) {\n    stream._inFlightWriteRequest = stream._writeRequests.shift();\n}\nfunction WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {\n    if (stream._closeRequest !== undefined) {\n        stream._closeRequest._reject(stream._storedError);\n        stream._closeRequest = undefined;\n    }\n    const writer = stream._writer;\n    if (writer !== undefined) {\n        defaultWriterClosedPromiseReject(writer, stream._storedError);\n    }\n}\nfunction WritableStreamUpdateBackpressure(stream, backpressure) {\n    const writer = stream._writer;\n    if (writer !== undefined && backpressure !== stream._backpressure) {\n        if (backpressure) {\n            defaultWriterReadyPromiseReset(writer);\n        }\n        else {\n            defaultWriterReadyPromiseResolve(writer);\n        }\n    }\n    stream._backpressure = backpressure;\n}\n/**\n * A default writer vended by a {@link WritableStream}.\n *\n * @public\n */\nclass WritableStreamDefaultWriter {\n    constructor(stream) {\n        assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');\n        assertWritableStream(stream, 'First parameter');\n        if (IsWritableStreamLocked(stream)) {\n            throw new TypeError('This stream has already been locked for exclusive writing by another writer');\n        }\n        this._ownerWritableStream = stream;\n        stream._writer = this;\n        const state = stream._state;\n        if (state === 'writable') {\n            if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {\n                defaultWriterReadyPromiseInitialize(this);\n            }\n            else {\n                defaultWriterReadyPromiseInitializeAsResolved(this);\n            }\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'erroring') {\n            defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);\n            defaultWriterClosedPromiseInitialize(this);\n        }\n        else if (state === 'closed') {\n            defaultWriterReadyPromiseInitializeAsResolved(this);\n            defaultWriterClosedPromiseInitializeAsResolved(this);\n        }\n        else {\n            const storedError = stream._storedError;\n            defaultWriterReadyPromiseInitializeAsRejected(this, storedError);\n            defaultWriterClosedPromiseInitializeAsRejected(this, storedError);\n        }\n    }\n    /**\n     * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or\n     * the writer’s lock is released before the stream finishes closing.\n     */\n    get closed() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('closed'));\n        }\n        return this._closedPromise;\n    }\n    /**\n     * Returns the desired size to fill the stream’s internal queue. It can be negative, if the queue is over-full.\n     * A producer can use this information to determine the right amount of data to write.\n     *\n     * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort\n     * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when\n     * the writer’s lock is released.\n     */\n    get desiredSize() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('desiredSize');\n        }\n        if (this._ownerWritableStream === undefined) {\n            throw defaultWriterLockException('desiredSize');\n        }\n        return WritableStreamDefaultWriterGetDesiredSize(this);\n    }\n    /**\n     * Returns a promise that will be fulfilled when the desired size to fill the stream’s internal queue transitions\n     * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips\n     * back to zero or below, the getter will return a new promise that stays pending until the next transition.\n     *\n     * If the stream becomes errored or aborted, or the writer’s lock is released, the returned promise will become\n     * rejected.\n     */\n    get ready() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('ready'));\n        }\n        return this._readyPromise;\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.\n     */\n    abort(reason = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('abort'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('abort'));\n        }\n        return WritableStreamDefaultWriterAbort(this, reason);\n    }\n    /**\n     * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.\n     */\n    close() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('close'));\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('close'));\n        }\n        if (WritableStreamCloseQueuedOrInFlight(stream)) {\n            return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));\n        }\n        return WritableStreamDefaultWriterClose(this);\n    }\n    /**\n     * Releases the writer’s lock on the corresponding stream. After the lock is released, the writer is no longer active.\n     * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from\n     * now on; otherwise, the writer will appear closed.\n     *\n     * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the\n     * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).\n     * It’s not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents\n     * other producers from writing in an interleaved manner.\n     */\n    releaseLock() {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            throw defaultWriterBrandCheckException('releaseLock');\n        }\n        const stream = this._ownerWritableStream;\n        if (stream === undefined) {\n            return;\n        }\n        WritableStreamDefaultWriterRelease(this);\n    }\n    write(chunk = undefined) {\n        if (!IsWritableStreamDefaultWriter(this)) {\n            return promiseRejectedWith(defaultWriterBrandCheckException('write'));\n        }\n        if (this._ownerWritableStream === undefined) {\n            return promiseRejectedWith(defaultWriterLockException('write to'));\n        }\n        return WritableStreamDefaultWriterWrite(this, chunk);\n    }\n}\nObject.defineProperties(WritableStreamDefaultWriter.prototype, {\n    abort: { enumerable: true },\n    close: { enumerable: true },\n    releaseLock: { enumerable: true },\n    write: { enumerable: true },\n    closed: { enumerable: true },\n    desiredSize: { enumerable: true },\n    ready: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultWriter',\n        configurable: true\n    });\n}\n// Abstract operations for the WritableStreamDefaultWriter.\nfunction IsWritableStreamDefaultWriter(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {\n        return false;\n    }\n    return true;\n}\n// A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.\nfunction WritableStreamDefaultWriterAbort(writer, reason) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamAbort(stream, reason);\n}\nfunction WritableStreamDefaultWriterClose(writer) {\n    const stream = writer._ownerWritableStream;\n    return WritableStreamClose(stream);\n}\nfunction WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    return WritableStreamDefaultWriterClose(writer);\n}\nfunction WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {\n    if (writer._closedPromiseState === 'pending') {\n        defaultWriterClosedPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterClosedPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {\n    if (writer._readyPromiseState === 'pending') {\n        defaultWriterReadyPromiseReject(writer, error);\n    }\n    else {\n        defaultWriterReadyPromiseResetToRejected(writer, error);\n    }\n}\nfunction WritableStreamDefaultWriterGetDesiredSize(writer) {\n    const stream = writer._ownerWritableStream;\n    const state = stream._state;\n    if (state === 'errored' || state === 'erroring') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);\n}\nfunction WritableStreamDefaultWriterRelease(writer) {\n    const stream = writer._ownerWritableStream;\n    const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);\n    WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);\n    // The state transitions to \"errored\" before the sink abort() method runs, but the writer.closed promise is not\n    // rejected until afterwards. This means that simply testing state will not work.\n    WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);\n    stream._writer = undefined;\n    writer._ownerWritableStream = undefined;\n}\nfunction WritableStreamDefaultWriterWrite(writer, chunk) {\n    const stream = writer._ownerWritableStream;\n    const controller = stream._writableStreamController;\n    const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);\n    if (stream !== writer._ownerWritableStream) {\n        return promiseRejectedWith(defaultWriterLockException('write to'));\n    }\n    const state = stream._state;\n    if (state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {\n        return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));\n    }\n    if (state === 'erroring') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    const promise = WritableStreamAddWriteRequest(stream);\n    WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);\n    return promise;\n}\nconst closeSentinel = {};\n/**\n * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.\n *\n * @public\n */\nclass WritableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.\n     *\n     * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying\n     * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the\n     * normal lifecycle of interactions with the underlying sink.\n     */\n    error(e = undefined) {\n        if (!IsWritableStreamDefaultController(this)) {\n            throw new TypeError('WritableStreamDefaultController.prototype.error can only be used on a WritableStreamDefaultController');\n        }\n        const state = this._controlledWritableStream._state;\n        if (state !== 'writable') {\n            // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so\n            // just treat it as a no-op.\n            return;\n        }\n        WritableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [AbortSteps](reason) {\n        const result = this._abortAlgorithm(reason);\n        WritableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [ErrorSteps]() {\n        ResetQueue(this);\n    }\n}\nObject.defineProperties(WritableStreamDefaultController.prototype, {\n    error: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'WritableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations implementing interface required by the WritableStream.\nfunction IsWritableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledWritableStream = stream;\n    stream._writableStreamController = controller;\n    // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._writeAlgorithm = writeAlgorithm;\n    controller._closeAlgorithm = closeAlgorithm;\n    controller._abortAlgorithm = abortAlgorithm;\n    const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n    WritableStreamUpdateBackpressure(stream, backpressure);\n    const startResult = startAlgorithm();\n    const startPromise = promiseResolvedWith(startResult);\n    uponPromise(startPromise, () => {\n        controller._started = true;\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, r => {\n        controller._started = true;\n        WritableStreamDealWithRejection(stream, r);\n    });\n}\nfunction SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(WritableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let writeAlgorithm = () => promiseResolvedWith(undefined);\n    let closeAlgorithm = () => promiseResolvedWith(undefined);\n    let abortAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSink.start !== undefined) {\n        startAlgorithm = () => underlyingSink.start(controller);\n    }\n    if (underlyingSink.write !== undefined) {\n        writeAlgorithm = chunk => underlyingSink.write(chunk, controller);\n    }\n    if (underlyingSink.close !== undefined) {\n        closeAlgorithm = () => underlyingSink.close();\n    }\n    if (underlyingSink.abort !== undefined) {\n        abortAlgorithm = reason => underlyingSink.abort(reason);\n    }\n    SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.\nfunction WritableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._writeAlgorithm = undefined;\n    controller._closeAlgorithm = undefined;\n    controller._abortAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\nfunction WritableStreamDefaultControllerClose(controller) {\n    EnqueueValueWithSize(controller, closeSentinel, 0);\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\nfunction WritableStreamDefaultControllerGetChunkSize(controller, chunk) {\n    try {\n        return controller._strategySizeAlgorithm(chunk);\n    }\n    catch (chunkSizeE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);\n        return 1;\n    }\n}\nfunction WritableStreamDefaultControllerGetDesiredSize(controller) {\n    return controller._strategyHWM - controller._queueTotalSize;\n}\nfunction WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {\n    try {\n        EnqueueValueWithSize(controller, chunk, chunkSize);\n    }\n    catch (enqueueE) {\n        WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);\n        return;\n    }\n    const stream = controller._controlledWritableStream;\n    if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {\n        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n        WritableStreamUpdateBackpressure(stream, backpressure);\n    }\n    WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n}\n// Abstract operations for the WritableStreamDefaultController.\nfunction WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {\n    const stream = controller._controlledWritableStream;\n    if (!controller._started) {\n        return;\n    }\n    if (stream._inFlightWriteRequest !== undefined) {\n        return;\n    }\n    const state = stream._state;\n    if (state === 'erroring') {\n        WritableStreamFinishErroring(stream);\n        return;\n    }\n    if (controller._queue.length === 0) {\n        return;\n    }\n    const value = PeekQueueValue(controller);\n    if (value === closeSentinel) {\n        WritableStreamDefaultControllerProcessClose(controller);\n    }\n    else {\n        WritableStreamDefaultControllerProcessWrite(controller, value);\n    }\n}\nfunction WritableStreamDefaultControllerErrorIfNeeded(controller, error) {\n    if (controller._controlledWritableStream._state === 'writable') {\n        WritableStreamDefaultControllerError(controller, error);\n    }\n}\nfunction WritableStreamDefaultControllerProcessClose(controller) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkCloseRequestInFlight(stream);\n    DequeueValue(controller);\n    const sinkClosePromise = controller._closeAlgorithm();\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    uponPromise(sinkClosePromise, () => {\n        WritableStreamFinishInFlightClose(stream);\n    }, reason => {\n        WritableStreamFinishInFlightCloseWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerProcessWrite(controller, chunk) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamMarkFirstWriteRequestInFlight(stream);\n    const sinkWritePromise = controller._writeAlgorithm(chunk);\n    uponPromise(sinkWritePromise, () => {\n        WritableStreamFinishInFlightWrite(stream);\n        const state = stream._state;\n        DequeueValue(controller);\n        if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {\n            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);\n            WritableStreamUpdateBackpressure(stream, backpressure);\n        }\n        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);\n    }, reason => {\n        if (stream._state === 'writable') {\n            WritableStreamDefaultControllerClearAlgorithms(controller);\n        }\n        WritableStreamFinishInFlightWriteWithError(stream, reason);\n    });\n}\nfunction WritableStreamDefaultControllerGetBackpressure(controller) {\n    const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);\n    return desiredSize <= 0;\n}\n// A client of WritableStreamDefaultController may use these functions directly to bypass state check.\nfunction WritableStreamDefaultControllerError(controller, error) {\n    const stream = controller._controlledWritableStream;\n    WritableStreamDefaultControllerClearAlgorithms(controller);\n    WritableStreamStartErroring(stream, error);\n}\n// Helper functions for the WritableStream.\nfunction streamBrandCheckException$2(name) {\n    return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);\n}\n// Helper functions for the WritableStreamDefaultWriter.\nfunction defaultWriterBrandCheckException(name) {\n    return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);\n}\nfunction defaultWriterLockException(name) {\n    return new TypeError('Cannot ' + name + ' a stream using a released writer');\n}\nfunction defaultWriterClosedPromiseInitialize(writer) {\n    writer._closedPromise = newPromise((resolve, reject) => {\n        writer._closedPromise_resolve = resolve;\n        writer._closedPromise_reject = reject;\n        writer._closedPromiseState = 'pending';\n    });\n}\nfunction defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseReject(writer, reason);\n}\nfunction defaultWriterClosedPromiseInitializeAsResolved(writer) {\n    defaultWriterClosedPromiseInitialize(writer);\n    defaultWriterClosedPromiseResolve(writer);\n}\nfunction defaultWriterClosedPromiseReject(writer, reason) {\n    if (writer._closedPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._closedPromise);\n    writer._closedPromise_reject(reason);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'rejected';\n}\nfunction defaultWriterClosedPromiseResetToRejected(writer, reason) {\n    defaultWriterClosedPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterClosedPromiseResolve(writer) {\n    if (writer._closedPromise_resolve === undefined) {\n        return;\n    }\n    writer._closedPromise_resolve(undefined);\n    writer._closedPromise_resolve = undefined;\n    writer._closedPromise_reject = undefined;\n    writer._closedPromiseState = 'resolved';\n}\nfunction defaultWriterReadyPromiseInitialize(writer) {\n    writer._readyPromise = newPromise((resolve, reject) => {\n        writer._readyPromise_resolve = resolve;\n        writer._readyPromise_reject = reject;\n    });\n    writer._readyPromiseState = 'pending';\n}\nfunction defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseReject(writer, reason);\n}\nfunction defaultWriterReadyPromiseInitializeAsResolved(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n    defaultWriterReadyPromiseResolve(writer);\n}\nfunction defaultWriterReadyPromiseReject(writer, reason) {\n    if (writer._readyPromise_reject === undefined) {\n        return;\n    }\n    setPromiseIsHandledToTrue(writer._readyPromise);\n    writer._readyPromise_reject(reason);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'rejected';\n}\nfunction defaultWriterReadyPromiseReset(writer) {\n    defaultWriterReadyPromiseInitialize(writer);\n}\nfunction defaultWriterReadyPromiseResetToRejected(writer, reason) {\n    defaultWriterReadyPromiseInitializeAsRejected(writer, reason);\n}\nfunction defaultWriterReadyPromiseResolve(writer) {\n    if (writer._readyPromise_resolve === undefined) {\n        return;\n    }\n    writer._readyPromise_resolve(undefined);\n    writer._readyPromise_resolve = undefined;\n    writer._readyPromise_reject = undefined;\n    writer._readyPromiseState = 'fulfilled';\n}\n\nfunction isAbortSignal(value) {\n    if (typeof value !== 'object' || value === null) {\n        return false;\n    }\n    try {\n        return typeof value.aborted === 'boolean';\n    }\n    catch (_a) {\n        // AbortSignal.prototype.aborted throws if its brand check fails\n        return false;\n    }\n}\n\n/// <reference lib=\"dom\" />\nconst NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;\n\n/// <reference types=\"node\" />\nfunction isDOMExceptionConstructor(ctor) {\n    if (!(typeof ctor === 'function' || typeof ctor === 'object')) {\n        return false;\n    }\n    try {\n        new ctor();\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n}\nfunction createDOMExceptionPolyfill() {\n    // eslint-disable-next-line no-shadow\n    const ctor = function DOMException(message, name) {\n        this.message = message || '';\n        this.name = name || 'Error';\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, this.constructor);\n        }\n    };\n    ctor.prototype = Object.create(Error.prototype);\n    Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });\n    return ctor;\n}\n// eslint-disable-next-line no-redeclare\nconst DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();\n\nfunction ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {\n    const reader = AcquireReadableStreamDefaultReader(source);\n    const writer = AcquireWritableStreamDefaultWriter(dest);\n    source._disturbed = true;\n    let shuttingDown = false;\n    // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.\n    let currentWrite = promiseResolvedWith(undefined);\n    return newPromise((resolve, reject) => {\n        let abortAlgorithm;\n        if (signal !== undefined) {\n            abortAlgorithm = () => {\n                const error = new DOMException$1('Aborted', 'AbortError');\n                const actions = [];\n                if (!preventAbort) {\n                    actions.push(() => {\n                        if (dest._state === 'writable') {\n                            return WritableStreamAbort(dest, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                if (!preventCancel) {\n                    actions.push(() => {\n                        if (source._state === 'readable') {\n                            return ReadableStreamCancel(source, error);\n                        }\n                        return promiseResolvedWith(undefined);\n                    });\n                }\n                shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);\n            };\n            if (signal.aborted) {\n                abortAlgorithm();\n                return;\n            }\n            signal.addEventListener('abort', abortAlgorithm);\n        }\n        // Using reader and writer, read all chunks from this and write them to dest\n        // - Backpressure must be enforced\n        // - Shutdown must stop all activity\n        function pipeLoop() {\n            return newPromise((resolveLoop, rejectLoop) => {\n                function next(done) {\n                    if (done) {\n                        resolveLoop();\n                    }\n                    else {\n                        // Use `PerformPromiseThen` instead of `uponPromise` to avoid\n                        // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers\n                        PerformPromiseThen(pipeStep(), next, rejectLoop);\n                    }\n                }\n                next(false);\n            });\n        }\n        function pipeStep() {\n            if (shuttingDown) {\n                return promiseResolvedWith(true);\n            }\n            return PerformPromiseThen(writer._readyPromise, () => {\n                return newPromise((resolveRead, rejectRead) => {\n                    ReadableStreamDefaultReaderRead(reader, {\n                        _chunkSteps: chunk => {\n                            currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);\n                            resolveRead(false);\n                        },\n                        _closeSteps: () => resolveRead(true),\n                        _errorSteps: rejectRead\n                    });\n                });\n            });\n        }\n        // Errors must be propagated forward\n        isOrBecomesErrored(source, reader._closedPromise, storedError => {\n            if (!preventAbort) {\n                shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Errors must be propagated backward\n        isOrBecomesErrored(dest, writer._closedPromise, storedError => {\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);\n            }\n            else {\n                shutdown(true, storedError);\n            }\n        });\n        // Closing must be propagated forward\n        isOrBecomesClosed(source, reader._closedPromise, () => {\n            if (!preventClose) {\n                shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));\n            }\n            else {\n                shutdown();\n            }\n        });\n        // Closing must be propagated backward\n        if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {\n            const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');\n            if (!preventCancel) {\n                shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);\n            }\n            else {\n                shutdown(true, destClosed);\n            }\n        }\n        setPromiseIsHandledToTrue(pipeLoop());\n        function waitForWritesToFinish() {\n            // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait\n            // for that too.\n            const oldCurrentWrite = currentWrite;\n            return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);\n        }\n        function isOrBecomesErrored(stream, promise, action) {\n            if (stream._state === 'errored') {\n                action(stream._storedError);\n            }\n            else {\n                uponRejection(promise, action);\n            }\n        }\n        function isOrBecomesClosed(stream, promise, action) {\n            if (stream._state === 'closed') {\n                action();\n            }\n            else {\n                uponFulfillment(promise, action);\n            }\n        }\n        function shutdownWithAction(action, originalIsError, originalError) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), doTheRest);\n            }\n            else {\n                doTheRest();\n            }\n            function doTheRest() {\n                uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));\n            }\n        }\n        function shutdown(isError, error) {\n            if (shuttingDown) {\n                return;\n            }\n            shuttingDown = true;\n            if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {\n                uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));\n            }\n            else {\n                finalize(isError, error);\n            }\n        }\n        function finalize(isError, error) {\n            WritableStreamDefaultWriterRelease(writer);\n            ReadableStreamReaderGenericRelease(reader);\n            if (signal !== undefined) {\n                signal.removeEventListener('abort', abortAlgorithm);\n            }\n            if (isError) {\n                reject(error);\n            }\n            else {\n                resolve(undefined);\n            }\n        }\n    });\n}\n\n/**\n * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.\n *\n * @public\n */\nclass ReadableStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is\n     * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.\n     */\n    get desiredSize() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('desiredSize');\n        }\n        return ReadableStreamDefaultControllerGetDesiredSize(this);\n    }\n    /**\n     * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from\n     * the stream, but once those are read, the stream will become closed.\n     */\n    close() {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('close');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits close');\n        }\n        ReadableStreamDefaultControllerClose(this);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('enqueue');\n        }\n        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {\n            throw new TypeError('The stream is not in a state that permits enqueue');\n        }\n        return ReadableStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.\n     */\n    error(e = undefined) {\n        if (!IsReadableStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException$1('error');\n        }\n        ReadableStreamDefaultControllerError(this, e);\n    }\n    /** @internal */\n    [CancelSteps](reason) {\n        ResetQueue(this);\n        const result = this._cancelAlgorithm(reason);\n        ReadableStreamDefaultControllerClearAlgorithms(this);\n        return result;\n    }\n    /** @internal */\n    [PullSteps](readRequest) {\n        const stream = this._controlledReadableStream;\n        if (this._queue.length > 0) {\n            const chunk = DequeueValue(this);\n            if (this._closeRequested && this._queue.length === 0) {\n                ReadableStreamDefaultControllerClearAlgorithms(this);\n                ReadableStreamClose(stream);\n            }\n            else {\n                ReadableStreamDefaultControllerCallPullIfNeeded(this);\n            }\n            readRequest._chunkSteps(chunk);\n        }\n        else {\n            ReadableStreamAddReadRequest(stream, readRequest);\n            ReadableStreamDefaultControllerCallPullIfNeeded(this);\n        }\n    }\n}\nObject.defineProperties(ReadableStreamDefaultController.prototype, {\n    close: { enumerable: true },\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStreamDefaultController',\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStreamDefaultController.\nfunction IsReadableStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCallPullIfNeeded(controller) {\n    const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);\n    if (!shouldPull) {\n        return;\n    }\n    if (controller._pulling) {\n        controller._pullAgain = true;\n        return;\n    }\n    controller._pulling = true;\n    const pullPromise = controller._pullAlgorithm();\n    uponPromise(pullPromise, () => {\n        controller._pulling = false;\n        if (controller._pullAgain) {\n            controller._pullAgain = false;\n            ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n        }\n    }, e => {\n        ReadableStreamDefaultControllerError(controller, e);\n    });\n}\nfunction ReadableStreamDefaultControllerShouldCallPull(controller) {\n    const stream = controller._controlledReadableStream;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return false;\n    }\n    if (!controller._started) {\n        return false;\n    }\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        return true;\n    }\n    const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);\n    if (desiredSize > 0) {\n        return true;\n    }\n    return false;\n}\nfunction ReadableStreamDefaultControllerClearAlgorithms(controller) {\n    controller._pullAlgorithm = undefined;\n    controller._cancelAlgorithm = undefined;\n    controller._strategySizeAlgorithm = undefined;\n}\n// A client of ReadableStreamDefaultController may use these functions directly to bypass state check.\nfunction ReadableStreamDefaultControllerClose(controller) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    controller._closeRequested = true;\n    if (controller._queue.length === 0) {\n        ReadableStreamDefaultControllerClearAlgorithms(controller);\n        ReadableStreamClose(stream);\n    }\n}\nfunction ReadableStreamDefaultControllerEnqueue(controller, chunk) {\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {\n        return;\n    }\n    const stream = controller._controlledReadableStream;\n    if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {\n        ReadableStreamFulfillReadRequest(stream, chunk, false);\n    }\n    else {\n        let chunkSize;\n        try {\n            chunkSize = controller._strategySizeAlgorithm(chunk);\n        }\n        catch (chunkSizeE) {\n            ReadableStreamDefaultControllerError(controller, chunkSizeE);\n            throw chunkSizeE;\n        }\n        try {\n            EnqueueValueWithSize(controller, chunk, chunkSize);\n        }\n        catch (enqueueE) {\n            ReadableStreamDefaultControllerError(controller, enqueueE);\n            throw enqueueE;\n        }\n    }\n    ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n}\nfunction ReadableStreamDefaultControllerError(controller, e) {\n    const stream = controller._controlledReadableStream;\n    if (stream._state !== 'readable') {\n        return;\n    }\n    ResetQueue(controller);\n    ReadableStreamDefaultControllerClearAlgorithms(controller);\n    ReadableStreamError(stream, e);\n}\nfunction ReadableStreamDefaultControllerGetDesiredSize(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (state === 'errored') {\n        return null;\n    }\n    if (state === 'closed') {\n        return 0;\n    }\n    return controller._strategyHWM - controller._queueTotalSize;\n}\n// This is used in the implementation of TransformStream.\nfunction ReadableStreamDefaultControllerHasBackpressure(controller) {\n    if (ReadableStreamDefaultControllerShouldCallPull(controller)) {\n        return false;\n    }\n    return true;\n}\nfunction ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {\n    const state = controller._controlledReadableStream._state;\n    if (!controller._closeRequested && state === 'readable') {\n        return true;\n    }\n    return false;\n}\nfunction SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {\n    controller._controlledReadableStream = stream;\n    controller._queue = undefined;\n    controller._queueTotalSize = undefined;\n    ResetQueue(controller);\n    controller._started = false;\n    controller._closeRequested = false;\n    controller._pullAgain = false;\n    controller._pulling = false;\n    controller._strategySizeAlgorithm = sizeAlgorithm;\n    controller._strategyHWM = highWaterMark;\n    controller._pullAlgorithm = pullAlgorithm;\n    controller._cancelAlgorithm = cancelAlgorithm;\n    stream._readableStreamController = controller;\n    const startResult = startAlgorithm();\n    uponPromise(promiseResolvedWith(startResult), () => {\n        controller._started = true;\n        ReadableStreamDefaultControllerCallPullIfNeeded(controller);\n    }, r => {\n        ReadableStreamDefaultControllerError(controller, r);\n    });\n}\nfunction SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    let startAlgorithm = () => undefined;\n    let pullAlgorithm = () => promiseResolvedWith(undefined);\n    let cancelAlgorithm = () => promiseResolvedWith(undefined);\n    if (underlyingSource.start !== undefined) {\n        startAlgorithm = () => underlyingSource.start(controller);\n    }\n    if (underlyingSource.pull !== undefined) {\n        pullAlgorithm = () => underlyingSource.pull(controller);\n    }\n    if (underlyingSource.cancel !== undefined) {\n        cancelAlgorithm = reason => underlyingSource.cancel(reason);\n    }\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n}\n// Helper functions for the ReadableStreamDefaultController.\nfunction defaultControllerBrandCheckException$1(name) {\n    return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);\n}\n\nfunction ReadableStreamTee(stream, cloneForBranch2) {\n    const reader = AcquireReadableStreamDefaultReader(stream);\n    let reading = false;\n    let canceled1 = false;\n    let canceled2 = false;\n    let reason1;\n    let reason2;\n    let branch1;\n    let branch2;\n    let resolveCancelPromise;\n    const cancelPromise = newPromise(resolve => {\n        resolveCancelPromise = resolve;\n    });\n    function pullAlgorithm() {\n        if (reading) {\n            return promiseResolvedWith(undefined);\n        }\n        reading = true;\n        const readRequest = {\n            _chunkSteps: value => {\n                // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using\n                // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let\n                // successful synchronously-available reads get ahead of asynchronously-available errors.\n                queueMicrotask(() => {\n                    reading = false;\n                    const value1 = value;\n                    const value2 = value;\n                    // There is no way to access the cloning code right now in the reference implementation.\n                    // If we add one then we'll need an implementation for serializable objects.\n                    // if (!canceled2 && cloneForBranch2) {\n                    //   value2 = StructuredDeserialize(StructuredSerialize(value2));\n                    // }\n                    if (!canceled1) {\n                        ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, value1);\n                    }\n                    if (!canceled2) {\n                        ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, value2);\n                    }\n                });\n            },\n            _closeSteps: () => {\n                reading = false;\n                if (!canceled1) {\n                    ReadableStreamDefaultControllerClose(branch1._readableStreamController);\n                }\n                if (!canceled2) {\n                    ReadableStreamDefaultControllerClose(branch2._readableStreamController);\n                }\n                if (!canceled1 || !canceled2) {\n                    resolveCancelPromise(undefined);\n                }\n            },\n            _errorSteps: () => {\n                reading = false;\n            }\n        };\n        ReadableStreamDefaultReaderRead(reader, readRequest);\n        return promiseResolvedWith(undefined);\n    }\n    function cancel1Algorithm(reason) {\n        canceled1 = true;\n        reason1 = reason;\n        if (canceled2) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function cancel2Algorithm(reason) {\n        canceled2 = true;\n        reason2 = reason;\n        if (canceled1) {\n            const compositeReason = CreateArrayFromList([reason1, reason2]);\n            const cancelResult = ReadableStreamCancel(stream, compositeReason);\n            resolveCancelPromise(cancelResult);\n        }\n        return cancelPromise;\n    }\n    function startAlgorithm() {\n        // do nothing\n    }\n    branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);\n    branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);\n    uponRejection(reader._closedPromise, (r) => {\n        ReadableStreamDefaultControllerError(branch1._readableStreamController, r);\n        ReadableStreamDefaultControllerError(branch2._readableStreamController, r);\n        if (!canceled1 || !canceled2) {\n            resolveCancelPromise(undefined);\n        }\n    });\n    return [branch1, branch2];\n}\n\nfunction convertUnderlyingDefaultOrByteSource(source, context) {\n    assertDictionary(source, context);\n    const original = source;\n    const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;\n    const cancel = original === null || original === void 0 ? void 0 : original.cancel;\n    const pull = original === null || original === void 0 ? void 0 : original.pull;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const type = original === null || original === void 0 ? void 0 : original.type;\n    return {\n        autoAllocateChunkSize: autoAllocateChunkSize === undefined ?\n            undefined :\n            convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),\n        cancel: cancel === undefined ?\n            undefined :\n            convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),\n        pull: pull === undefined ?\n            undefined :\n            convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),\n        start: start === undefined ?\n            undefined :\n            convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),\n        type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)\n    };\n}\nfunction convertUnderlyingSourceCancelCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (reason) => promiseCall(fn, original, [reason]);\n}\nfunction convertUnderlyingSourcePullCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertUnderlyingSourceStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertReadableStreamType(type, context) {\n    type = `${type}`;\n    if (type !== 'bytes') {\n        throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);\n    }\n    return type;\n}\n\nfunction convertReaderOptions(options, context) {\n    assertDictionary(options, context);\n    const mode = options === null || options === void 0 ? void 0 : options.mode;\n    return {\n        mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)\n    };\n}\nfunction convertReadableStreamReaderMode(mode, context) {\n    mode = `${mode}`;\n    if (mode !== 'byob') {\n        throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);\n    }\n    return mode;\n}\n\nfunction convertIteratorOptions(options, context) {\n    assertDictionary(options, context);\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    return { preventCancel: Boolean(preventCancel) };\n}\n\nfunction convertPipeOptions(options, context) {\n    assertDictionary(options, context);\n    const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;\n    const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;\n    const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;\n    const signal = options === null || options === void 0 ? void 0 : options.signal;\n    if (signal !== undefined) {\n        assertAbortSignal(signal, `${context} has member 'signal' that`);\n    }\n    return {\n        preventAbort: Boolean(preventAbort),\n        preventCancel: Boolean(preventCancel),\n        preventClose: Boolean(preventClose),\n        signal\n    };\n}\nfunction assertAbortSignal(signal, context) {\n    if (!isAbortSignal(signal)) {\n        throw new TypeError(`${context} is not an AbortSignal.`);\n    }\n}\n\nfunction convertReadableWritablePair(pair, context) {\n    assertDictionary(pair, context);\n    const readable = pair === null || pair === void 0 ? void 0 : pair.readable;\n    assertRequiredField(readable, 'readable', 'ReadableWritablePair');\n    assertReadableStream(readable, `${context} has member 'readable' that`);\n    const writable = pair === null || pair === void 0 ? void 0 : pair.writable;\n    assertRequiredField(writable, 'writable', 'ReadableWritablePair');\n    assertWritableStream(writable, `${context} has member 'writable' that`);\n    return { readable, writable };\n}\n\n/**\n * A readable stream represents a source of data, from which you can read.\n *\n * @public\n */\nclass ReadableStream {\n    constructor(rawUnderlyingSource = {}, rawStrategy = {}) {\n        if (rawUnderlyingSource === undefined) {\n            rawUnderlyingSource = null;\n        }\n        else {\n            assertObject(rawUnderlyingSource, 'First parameter');\n        }\n        const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');\n        const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');\n        InitializeReadableStream(this);\n        if (underlyingSource.type === 'bytes') {\n            if (strategy.size !== undefined) {\n                throw new RangeError('The strategy for a byte stream cannot have a size function');\n            }\n            const highWaterMark = ExtractHighWaterMark(strategy, 0);\n            SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);\n        }\n        else {\n            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);\n            const highWaterMark = ExtractHighWaterMark(strategy, 1);\n            SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);\n        }\n    }\n    /**\n     * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.\n     */\n    get locked() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('locked');\n        }\n        return IsReadableStreamLocked(this);\n    }\n    /**\n     * Cancels the stream, signaling a loss of interest in the stream by a consumer.\n     *\n     * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}\n     * method, which might or might not use it.\n     */\n    cancel(reason = undefined) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('cancel'));\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));\n        }\n        return ReadableStreamCancel(this, reason);\n    }\n    getReader(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('getReader');\n        }\n        const options = convertReaderOptions(rawOptions, 'First parameter');\n        if (options.mode === undefined) {\n            return AcquireReadableStreamDefaultReader(this);\n        }\n        return AcquireReadableStreamBYOBReader(this);\n    }\n    pipeThrough(rawTransform, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('pipeThrough');\n        }\n        assertRequiredArgument(rawTransform, 1, 'pipeThrough');\n        const transform = convertReadableWritablePair(rawTransform, 'First parameter');\n        const options = convertPipeOptions(rawOptions, 'Second parameter');\n        if (IsReadableStreamLocked(this)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');\n        }\n        if (IsWritableStreamLocked(transform.writable)) {\n            throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');\n        }\n        const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n        setPromiseIsHandledToTrue(promise);\n        return transform.readable;\n    }\n    pipeTo(destination, rawOptions = {}) {\n        if (!IsReadableStream(this)) {\n            return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));\n        }\n        if (destination === undefined) {\n            return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);\n        }\n        if (!IsWritableStream(destination)) {\n            return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));\n        }\n        let options;\n        try {\n            options = convertPipeOptions(rawOptions, 'Second parameter');\n        }\n        catch (e) {\n            return promiseRejectedWith(e);\n        }\n        if (IsReadableStreamLocked(this)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));\n        }\n        if (IsWritableStreamLocked(destination)) {\n            return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));\n        }\n        return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);\n    }\n    /**\n     * Tees this readable stream, returning a two-element array containing the two resulting branches as\n     * new {@link ReadableStream} instances.\n     *\n     * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.\n     * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be\n     * propagated to the stream's underlying source.\n     *\n     * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,\n     * this could allow interference between the two branches.\n     */\n    tee() {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('tee');\n        }\n        const branches = ReadableStreamTee(this);\n        return CreateArrayFromList(branches);\n    }\n    values(rawOptions = undefined) {\n        if (!IsReadableStream(this)) {\n            throw streamBrandCheckException$1('values');\n        }\n        const options = convertIteratorOptions(rawOptions, 'First parameter');\n        return AcquireReadableStreamAsyncIterator(this, options.preventCancel);\n    }\n}\nObject.defineProperties(ReadableStream.prototype, {\n    cancel: { enumerable: true },\n    getReader: { enumerable: true },\n    pipeThrough: { enumerable: true },\n    pipeTo: { enumerable: true },\n    tee: { enumerable: true },\n    values: { enumerable: true },\n    locked: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ReadableStream',\n        configurable: true\n    });\n}\nif (typeof SymbolPolyfill.asyncIterator === 'symbol') {\n    Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {\n        value: ReadableStream.prototype.values,\n        writable: true,\n        configurable: true\n    });\n}\n// Abstract operations for the ReadableStream.\n// Throws if and only if startAlgorithm throws.\nfunction CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {\n    const stream = Object.create(ReadableStream.prototype);\n    InitializeReadableStream(stream);\n    const controller = Object.create(ReadableStreamDefaultController.prototype);\n    SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);\n    return stream;\n}\nfunction InitializeReadableStream(stream) {\n    stream._state = 'readable';\n    stream._reader = undefined;\n    stream._storedError = undefined;\n    stream._disturbed = false;\n}\nfunction IsReadableStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {\n        return false;\n    }\n    return true;\n}\nfunction IsReadableStreamLocked(stream) {\n    if (stream._reader === undefined) {\n        return false;\n    }\n    return true;\n}\n// ReadableStream API exposed for controllers.\nfunction ReadableStreamCancel(stream, reason) {\n    stream._disturbed = true;\n    if (stream._state === 'closed') {\n        return promiseResolvedWith(undefined);\n    }\n    if (stream._state === 'errored') {\n        return promiseRejectedWith(stream._storedError);\n    }\n    ReadableStreamClose(stream);\n    const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);\n    return transformPromiseWith(sourceCancelPromise, noop);\n}\nfunction ReadableStreamClose(stream) {\n    stream._state = 'closed';\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseResolve(reader);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._closeSteps();\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n}\nfunction ReadableStreamError(stream, e) {\n    stream._state = 'errored';\n    stream._storedError = e;\n    const reader = stream._reader;\n    if (reader === undefined) {\n        return;\n    }\n    defaultReaderClosedPromiseReject(reader, e);\n    if (IsReadableStreamDefaultReader(reader)) {\n        reader._readRequests.forEach(readRequest => {\n            readRequest._errorSteps(e);\n        });\n        reader._readRequests = new SimpleQueue();\n    }\n    else {\n        reader._readIntoRequests.forEach(readIntoRequest => {\n            readIntoRequest._errorSteps(e);\n        });\n        reader._readIntoRequests = new SimpleQueue();\n    }\n}\n// Helper functions for the ReadableStream.\nfunction streamBrandCheckException$1(name) {\n    return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);\n}\n\nfunction convertQueuingStrategyInit(init, context) {\n    assertDictionary(init, context);\n    const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;\n    assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');\n    return {\n        highWaterMark: convertUnrestrictedDouble(highWaterMark)\n    };\n}\n\nconst byteLengthSizeFunction = function size(chunk) {\n    return chunk.byteLength;\n};\n/**\n * A queuing strategy that counts the number of bytes in each chunk.\n *\n * @public\n */\nclass ByteLengthQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('highWaterMark');\n        }\n        return this._byteLengthQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by returning the value of its `byteLength` property.\n     */\n    get size() {\n        if (!IsByteLengthQueuingStrategy(this)) {\n            throw byteLengthBrandCheckException('size');\n        }\n        return byteLengthSizeFunction;\n    }\n}\nObject.defineProperties(ByteLengthQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'ByteLengthQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the ByteLengthQueuingStrategy.\nfunction byteLengthBrandCheckException(name) {\n    return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);\n}\nfunction IsByteLengthQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nconst countSizeFunction = function size() {\n    return 1;\n};\n/**\n * A queuing strategy that counts the number of chunks.\n *\n * @public\n */\nclass CountQueuingStrategy {\n    constructor(options) {\n        assertRequiredArgument(options, 1, 'CountQueuingStrategy');\n        options = convertQueuingStrategyInit(options, 'First parameter');\n        this._countQueuingStrategyHighWaterMark = options.highWaterMark;\n    }\n    /**\n     * Returns the high water mark provided to the constructor.\n     */\n    get highWaterMark() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('highWaterMark');\n        }\n        return this._countQueuingStrategyHighWaterMark;\n    }\n    /**\n     * Measures the size of `chunk` by always returning 1.\n     * This ensures that the total queue size is a count of the number of chunks in the queue.\n     */\n    get size() {\n        if (!IsCountQueuingStrategy(this)) {\n            throw countBrandCheckException('size');\n        }\n        return countSizeFunction;\n    }\n}\nObject.defineProperties(CountQueuingStrategy.prototype, {\n    highWaterMark: { enumerable: true },\n    size: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {\n        value: 'CountQueuingStrategy',\n        configurable: true\n    });\n}\n// Helper functions for the CountQueuingStrategy.\nfunction countBrandCheckException(name) {\n    return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);\n}\nfunction IsCountQueuingStrategy(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {\n        return false;\n    }\n    return true;\n}\n\nfunction convertTransformer(original, context) {\n    assertDictionary(original, context);\n    const flush = original === null || original === void 0 ? void 0 : original.flush;\n    const readableType = original === null || original === void 0 ? void 0 : original.readableType;\n    const start = original === null || original === void 0 ? void 0 : original.start;\n    const transform = original === null || original === void 0 ? void 0 : original.transform;\n    const writableType = original === null || original === void 0 ? void 0 : original.writableType;\n    return {\n        flush: flush === undefined ?\n            undefined :\n            convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),\n        readableType,\n        start: start === undefined ?\n            undefined :\n            convertTransformerStartCallback(start, original, `${context} has member 'start' that`),\n        transform: transform === undefined ?\n            undefined :\n            convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),\n        writableType\n    };\n}\nfunction convertTransformerFlushCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => promiseCall(fn, original, [controller]);\n}\nfunction convertTransformerStartCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (controller) => reflectCall(fn, original, [controller]);\n}\nfunction convertTransformerTransformCallback(fn, original, context) {\n    assertFunction(fn, context);\n    return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);\n}\n\n// Class TransformStream\n/**\n * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},\n * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.\n * In a manner specific to the transform stream in question, writes to the writable side result in new data being\n * made available for reading from the readable side.\n *\n * @public\n */\nclass TransformStream {\n    constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {\n        if (rawTransformer === undefined) {\n            rawTransformer = null;\n        }\n        const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');\n        const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');\n        const transformer = convertTransformer(rawTransformer, 'First parameter');\n        if (transformer.readableType !== undefined) {\n            throw new RangeError('Invalid readableType specified');\n        }\n        if (transformer.writableType !== undefined) {\n            throw new RangeError('Invalid writableType specified');\n        }\n        const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);\n        const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);\n        const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);\n        const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);\n        let startPromise_resolve;\n        const startPromise = newPromise(resolve => {\n            startPromise_resolve = resolve;\n        });\n        InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n        SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);\n        if (transformer.start !== undefined) {\n            startPromise_resolve(transformer.start(this._transformStreamController));\n        }\n        else {\n            startPromise_resolve(undefined);\n        }\n    }\n    /**\n     * The readable side of the transform stream.\n     */\n    get readable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('readable');\n        }\n        return this._readable;\n    }\n    /**\n     * The writable side of the transform stream.\n     */\n    get writable() {\n        if (!IsTransformStream(this)) {\n            throw streamBrandCheckException('writable');\n        }\n        return this._writable;\n    }\n}\nObject.defineProperties(TransformStream.prototype, {\n    readable: { enumerable: true },\n    writable: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStream',\n        configurable: true\n    });\n}\nfunction InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {\n    function startAlgorithm() {\n        return startPromise;\n    }\n    function writeAlgorithm(chunk) {\n        return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);\n    }\n    function abortAlgorithm(reason) {\n        return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);\n    }\n    function closeAlgorithm() {\n        return TransformStreamDefaultSinkCloseAlgorithm(stream);\n    }\n    stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);\n    function pullAlgorithm() {\n        return TransformStreamDefaultSourcePullAlgorithm(stream);\n    }\n    function cancelAlgorithm(reason) {\n        TransformStreamErrorWritableAndUnblockWrite(stream, reason);\n        return promiseResolvedWith(undefined);\n    }\n    stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);\n    // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.\n    stream._backpressure = undefined;\n    stream._backpressureChangePromise = undefined;\n    stream._backpressureChangePromise_resolve = undefined;\n    TransformStreamSetBackpressure(stream, true);\n    stream._transformStreamController = undefined;\n}\nfunction IsTransformStream(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {\n        return false;\n    }\n    return true;\n}\n// This is a no-op if both sides are already errored.\nfunction TransformStreamError(stream, e) {\n    ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);\n    TransformStreamErrorWritableAndUnblockWrite(stream, e);\n}\nfunction TransformStreamErrorWritableAndUnblockWrite(stream, e) {\n    TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);\n    WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);\n    if (stream._backpressure) {\n        // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()\n        // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time\n        // _backpressure is set.\n        TransformStreamSetBackpressure(stream, false);\n    }\n}\nfunction TransformStreamSetBackpressure(stream, backpressure) {\n    // Passes also when called during construction.\n    if (stream._backpressureChangePromise !== undefined) {\n        stream._backpressureChangePromise_resolve();\n    }\n    stream._backpressureChangePromise = newPromise(resolve => {\n        stream._backpressureChangePromise_resolve = resolve;\n    });\n    stream._backpressure = backpressure;\n}\n// Class TransformStreamDefaultController\n/**\n * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.\n *\n * @public\n */\nclass TransformStreamDefaultController {\n    constructor() {\n        throw new TypeError('Illegal constructor');\n    }\n    /**\n     * Returns the desired size to fill the readable side’s internal queue. It can be negative, if the queue is over-full.\n     */\n    get desiredSize() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('desiredSize');\n        }\n        const readableController = this._controlledTransformStream._readable._readableStreamController;\n        return ReadableStreamDefaultControllerGetDesiredSize(readableController);\n    }\n    enqueue(chunk = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('enqueue');\n        }\n        TransformStreamDefaultControllerEnqueue(this, chunk);\n    }\n    /**\n     * Errors both the readable side and the writable side of the controlled transform stream, making all future\n     * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.\n     */\n    error(reason = undefined) {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('error');\n        }\n        TransformStreamDefaultControllerError(this, reason);\n    }\n    /**\n     * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the\n     * transformer only needs to consume a portion of the chunks written to the writable side.\n     */\n    terminate() {\n        if (!IsTransformStreamDefaultController(this)) {\n            throw defaultControllerBrandCheckException('terminate');\n        }\n        TransformStreamDefaultControllerTerminate(this);\n    }\n}\nObject.defineProperties(TransformStreamDefaultController.prototype, {\n    enqueue: { enumerable: true },\n    error: { enumerable: true },\n    terminate: { enumerable: true },\n    desiredSize: { enumerable: true }\n});\nif (typeof SymbolPolyfill.toStringTag === 'symbol') {\n    Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {\n        value: 'TransformStreamDefaultController',\n        configurable: true\n    });\n}\n// Transform Stream Default Controller Abstract Operations\nfunction IsTransformStreamDefaultController(x) {\n    if (!typeIsObject(x)) {\n        return false;\n    }\n    if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {\n        return false;\n    }\n    return true;\n}\nfunction SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {\n    controller._controlledTransformStream = stream;\n    stream._transformStreamController = controller;\n    controller._transformAlgorithm = transformAlgorithm;\n    controller._flushAlgorithm = flushAlgorithm;\n}\nfunction SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {\n    const controller = Object.create(TransformStreamDefaultController.prototype);\n    let transformAlgorithm = (chunk) => {\n        try {\n            TransformStreamDefaultControllerEnqueue(controller, chunk);\n            return promiseResolvedWith(undefined);\n        }\n        catch (transformResultE) {\n            return promiseRejectedWith(transformResultE);\n        }\n    };\n    let flushAlgorithm = () => promiseResolvedWith(undefined);\n    if (transformer.transform !== undefined) {\n        transformAlgorithm = chunk => transformer.transform(chunk, controller);\n    }\n    if (transformer.flush !== undefined) {\n        flushAlgorithm = () => transformer.flush(controller);\n    }\n    SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);\n}\nfunction TransformStreamDefaultControllerClearAlgorithms(controller) {\n    controller._transformAlgorithm = undefined;\n    controller._flushAlgorithm = undefined;\n}\nfunction TransformStreamDefaultControllerEnqueue(controller, chunk) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {\n        throw new TypeError('Readable side is not in a state that permits enqueue');\n    }\n    // We throttle transform invocations based on the backpressure of the ReadableStream, but we still\n    // accept TransformStreamDefaultControllerEnqueue() calls.\n    try {\n        ReadableStreamDefaultControllerEnqueue(readableController, chunk);\n    }\n    catch (e) {\n        // This happens when readableStrategy.size() throws.\n        TransformStreamErrorWritableAndUnblockWrite(stream, e);\n        throw stream._readable._storedError;\n    }\n    const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);\n    if (backpressure !== stream._backpressure) {\n        TransformStreamSetBackpressure(stream, true);\n    }\n}\nfunction TransformStreamDefaultControllerError(controller, e) {\n    TransformStreamError(controller._controlledTransformStream, e);\n}\nfunction TransformStreamDefaultControllerPerformTransform(controller, chunk) {\n    const transformPromise = controller._transformAlgorithm(chunk);\n    return transformPromiseWith(transformPromise, undefined, r => {\n        TransformStreamError(controller._controlledTransformStream, r);\n        throw r;\n    });\n}\nfunction TransformStreamDefaultControllerTerminate(controller) {\n    const stream = controller._controlledTransformStream;\n    const readableController = stream._readable._readableStreamController;\n    ReadableStreamDefaultControllerClose(readableController);\n    const error = new TypeError('TransformStream terminated');\n    TransformStreamErrorWritableAndUnblockWrite(stream, error);\n}\n// TransformStreamDefaultSink Algorithms\nfunction TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {\n    const controller = stream._transformStreamController;\n    if (stream._backpressure) {\n        const backpressureChangePromise = stream._backpressureChangePromise;\n        return transformPromiseWith(backpressureChangePromise, () => {\n            const writable = stream._writable;\n            const state = writable._state;\n            if (state === 'erroring') {\n                throw writable._storedError;\n            }\n            return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n        });\n    }\n    return TransformStreamDefaultControllerPerformTransform(controller, chunk);\n}\nfunction TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {\n    // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already\n    // errored.\n    TransformStreamError(stream, reason);\n    return promiseResolvedWith(undefined);\n}\nfunction TransformStreamDefaultSinkCloseAlgorithm(stream) {\n    // stream._readable cannot change after construction, so caching it across a call to user code is safe.\n    const readable = stream._readable;\n    const controller = stream._transformStreamController;\n    const flushPromise = controller._flushAlgorithm();\n    TransformStreamDefaultControllerClearAlgorithms(controller);\n    // Return a promise that is fulfilled with undefined on success.\n    return transformPromiseWith(flushPromise, () => {\n        if (readable._state === 'errored') {\n            throw readable._storedError;\n        }\n        ReadableStreamDefaultControllerClose(readable._readableStreamController);\n    }, r => {\n        TransformStreamError(stream, r);\n        throw readable._storedError;\n    });\n}\n// TransformStreamDefaultSource Algorithms\nfunction TransformStreamDefaultSourcePullAlgorithm(stream) {\n    // Invariant. Enforced by the promises returned by start() and pull().\n    TransformStreamSetBackpressure(stream, false);\n    // Prevent the next pull() call until there is backpressure.\n    return stream._backpressureChangePromise;\n}\n// Helper functions for the TransformStreamDefaultController.\nfunction defaultControllerBrandCheckException(name) {\n    return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);\n}\n// Helper functions for the TransformStream.\nfunction streamBrandCheckException(name) {\n    return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);\n}\n\nexport { ByteLengthQueuingStrategy, CountQueuingStrategy, ReadableByteStreamController, ReadableStream, ReadableStreamBYOBReader, ReadableStreamBYOBRequest, ReadableStreamDefaultController, ReadableStreamDefaultReader, TransformStream, TransformStreamDefaultController, WritableStream, WritableStreamDefaultController, WritableStreamDefaultWriter };\n//# sourceMappingURL=ponyfill.es6.mjs.map\n"],"names":["SymbolPolyfill","Symbol","iterator","description","noop","globals","self","window","global","typeIsObject","x","rethrowAssertionErrorRejection","originalPromise","Promise","originalPromiseThen","prototype","then","originalPromiseResolve","resolve","bind","originalPromiseReject","reject","newPromise","executor","promiseResolvedWith","value","promiseRejectedWith","reason","PerformPromiseThen","promise","onFulfilled","onRejected","call","uponPromise","undefined","uponFulfillment","uponRejection","transformPromiseWith","fulfillmentHandler","rejectionHandler","setPromiseIsHandledToTrue","queueMicrotask","globalQueueMicrotask","resolvedPromise","fn","reflectCall","F","V","args","TypeError","Function","apply","promiseCall","SimpleQueue","constructor","this","_cursor","_size","_front","_elements","_next","_back","length","push","element","oldBack","newBack","QUEUE_MAX_ARRAY_SIZE","shift","oldFront","newFront","oldCursor","newCursor","elements","forEach","callback","i","node","peek","front","cursor","ReadableStreamReaderGenericInitialize","reader","stream","_ownerReadableStream","_reader","_state","defaultReaderClosedPromiseInitialize","defaultReaderClosedPromiseResolve","defaultReaderClosedPromiseInitializeAsResolved","defaultReaderClosedPromiseInitializeAsRejected","_storedError","ReadableStreamReaderGenericCancel","ReadableStreamCancel","ReadableStreamReaderGenericRelease","defaultReaderClosedPromiseReject","defaultReaderClosedPromiseResetToRejected","readerLockException","name","_closedPromise","_closedPromise_resolve","_closedPromise_reject","AbortSteps","ErrorSteps","CancelSteps","PullSteps","NumberIsFinite","Number","isFinite","MathTrunc","Math","trunc","v","ceil","floor","assertDictionary","obj","context","assertFunction","assertObject","isObject","assertRequiredArgument","position","assertRequiredField","field","convertUnrestrictedDouble","censorNegativeZero","convertUnsignedLongLongWithEnforceRange","upperBound","MAX_SAFE_INTEGER","integerPart","assertReadableStream","IsReadableStream","AcquireReadableStreamDefaultReader","ReadableStreamDefaultReader","ReadableStreamAddReadRequest","readRequest","_readRequests","ReadableStreamFulfillReadRequest","chunk","done","_closeSteps","_chunkSteps","ReadableStreamGetNumReadRequests","ReadableStreamHasDefaultReader","IsReadableStreamDefaultReader","IsReadableStreamLocked","closed","defaultReaderBrandCheckException","cancel","read","resolvePromise","rejectPromise","ReadableStreamDefaultReaderRead","_errorSteps","e","releaseLock","Object","hasOwnProperty","_disturbed","_readableStreamController","AsyncIteratorPrototype","defineProperties","enumerable","toStringTag","defineProperty","configurable","asyncIterator","ReadableStreamAsyncIteratorImpl","preventCancel","_ongoingPromise","_isFinished","_preventCancel","next","nextSteps","_nextSteps","return","returnSteps","_returnSteps","result","ReadableStreamAsyncIteratorPrototype","IsReadableStreamAsyncIterator","_asyncIteratorImpl","streamAsyncIteratorBrandCheckException","setPrototypeOf","NumberIsNaN","isNaN","IsFiniteNonNegativeNumber","IsNonNegativeNumber","Infinity","DequeueValue","container","pair","_queue","_queueTotalSize","size","EnqueueValueWithSize","RangeError","ResetQueue","CreateArrayFromList","slice","ReadableStreamBYOBRequest","view","IsReadableStreamBYOBRequest","byobRequestBrandCheckException","_view","respond","bytesWritten","_associatedReadableByteStreamController","buffer","controller","ReadableByteStreamControllerRespondInternal","ReadableByteStreamControllerRespond","respondWithNewView","ArrayBuffer","isView","byteLength","firstDescriptor","_pendingPullIntos","byteOffset","bytesFilled","ReadableByteStreamControllerRespondWithNewView","ReadableByteStreamController","byobRequest","IsReadableByteStreamController","byteStreamControllerBrandCheckException","_byobRequest","Uint8Array","create","request","SetUpReadableStreamBYOBRequest","desiredSize","ReadableByteStreamControllerGetDesiredSize","close","_closeRequested","state","_controlledReadableByteStream","ReadableByteStreamControllerError","ReadableByteStreamControllerClearAlgorithms","ReadableStreamClose","ReadableByteStreamControllerClose","enqueue","transferredBuffer","ReadableByteStreamControllerEnqueueChunkToQueue","ReadableStreamHasBYOBReader","ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue","ReadableByteStreamControllerCallPullIfNeeded","ReadableByteStreamControllerEnqueue","error","_cancelAlgorithm","entry","ReadableByteStreamControllerHandleQueueDrain","autoAllocateChunkSize","_autoAllocateChunkSize","bufferE","pullIntoDescriptor","elementSize","viewConstructor","readerType","shouldPull","_started","ReadableStreamGetNumReadIntoRequests","ReadableByteStreamControllerShouldCallPull","_pulling","_pullAgain","_pullAlgorithm","ReadableByteStreamControllerCommitPullIntoDescriptor","filledView","ReadableByteStreamControllerConvertPullIntoDescriptor","readIntoRequest","_readIntoRequests","ReadableStreamFulfillReadIntoRequest","ReadableByteStreamControllerFillPullIntoDescriptorFromQueue","currentAlignedBytes","maxBytesToCopy","min","maxBytesFilled","maxAlignedBytes","totalBytesToCopyRemaining","ready","queue","headOfQueue","bytesToCopy","destStart","dest","destOffset","src","srcOffset","n","set","ReadableByteStreamControllerFillHeadPullIntoDescriptor","ReadableByteStreamControllerInvalidateBYOBRequest","ReadableByteStreamControllerShiftPendingPullInto","ReadableByteStreamControllerRespondInClosedState","remainderSize","end","remainder","ReadableByteStreamControllerRespondInReadableState","descriptor","ReadableByteStreamControllerClearPendingPullIntos","ReadableStreamError","_strategyHWM","SetUpReadableByteStreamControllerFromUnderlyingSource","underlyingByteSource","highWaterMark","startAlgorithm","pullAlgorithm","cancelAlgorithm","start","pull","r","SetUpReadableByteStreamController","ReadableStreamAddReadIntoRequest","IsReadableStreamBYOBReader","ReadableStreamBYOBReader","byobReaderBrandCheckException","DataView","BYTES_PER_ELEMENT","ctor","emptyView","ReadableByteStreamControllerPullInto","ReadableStreamBYOBReaderRead","ExtractHighWaterMark","strategy","defaultHWM","ExtractSizeAlgorithm","convertQueuingStrategy","init","convertQueuingStrategySize","convertUnderlyingSinkAbortCallback","original","convertUnderlyingSinkCloseCallback","convertUnderlyingSinkStartCallback","convertUnderlyingSinkWriteCallback","assertWritableStream","IsWritableStream","WritableStream","rawUnderlyingSink","rawStrategy","underlyingSink","abort","type","write","convertUnderlyingSink","InitializeWritableStream","sizeAlgorithm","WritableStreamDefaultController","writeAlgorithm","closeAlgorithm","abortAlgorithm","SetUpWritableStreamDefaultController","SetUpWritableStreamDefaultControllerFromUnderlyingSink","locked","streamBrandCheckException$2","IsWritableStreamLocked","WritableStreamAbort","WritableStreamCloseQueuedOrInFlight","WritableStreamClose","getWriter","AcquireWritableStreamDefaultWriter","WritableStreamDefaultWriter","_writer","_writableStreamController","_writeRequests","_inFlightWriteRequest","_closeRequest","_inFlightCloseRequest","_pendingAbortRequest","_backpressure","_promise","wasAlreadyErroring","_resolve","_reject","_reason","_wasAlreadyErroring","WritableStreamStartErroring","closeRequest","writer","defaultWriterReadyPromiseResolve","closeSentinel","WritableStreamDefaultControllerAdvanceQueueIfNeeded","WritableStreamDealWithRejection","WritableStreamFinishErroring","WritableStreamDefaultWriterEnsureReadyPromiseRejected","WritableStreamHasOperationMarkedInFlight","storedError","writeRequest","WritableStreamRejectCloseAndClosedPromiseIfNeeded","abortRequest","defaultWriterClosedPromiseReject","WritableStreamUpdateBackpressure","backpressure","defaultWriterReadyPromiseInitialize","defaultWriterReadyPromiseReset","_ownerWritableStream","defaultWriterReadyPromiseInitializeAsResolved","defaultWriterClosedPromiseInitialize","defaultWriterReadyPromiseInitializeAsRejected","defaultWriterClosedPromiseResolve","defaultWriterClosedPromiseInitializeAsRejected","IsWritableStreamDefaultWriter","defaultWriterBrandCheckException","defaultWriterLockException","WritableStreamDefaultControllerGetDesiredSize","WritableStreamDefaultWriterGetDesiredSize","_readyPromise","WritableStreamDefaultWriterAbort","WritableStreamDefaultWriterClose","WritableStreamDefaultWriterRelease","WritableStreamDefaultWriterWrite","WritableStreamDefaultWriterEnsureClosedPromiseRejected","_closedPromiseState","defaultWriterClosedPromiseResetToRejected","_readyPromiseState","defaultWriterReadyPromiseReject","defaultWriterReadyPromiseResetToRejected","releasedError","chunkSize","_strategySizeAlgorithm","chunkSizeE","WritableStreamDefaultControllerErrorIfNeeded","WritableStreamDefaultControllerGetChunkSize","WritableStreamAddWriteRequest","enqueueE","_controlledWritableStream","WritableStreamDefaultControllerGetBackpressure","WritableStreamDefaultControllerWrite","IsWritableStreamDefaultController","WritableStreamDefaultControllerError","_abortAlgorithm","WritableStreamDefaultControllerClearAlgorithms","_writeAlgorithm","_closeAlgorithm","WritableStreamMarkCloseRequestInFlight","sinkClosePromise","WritableStreamFinishInFlightClose","WritableStreamFinishInFlightCloseWithError","WritableStreamDefaultControllerProcessClose","WritableStreamMarkFirstWriteRequestInFlight","sinkWritePromise","WritableStreamFinishInFlightWrite","WritableStreamFinishInFlightWriteWithError","WritableStreamDefaultControllerProcessWrite","_readyPromise_resolve","_readyPromise_reject","NativeDOMException","DOMException","DOMException$1","_a","isDOMExceptionConstructor","message","Error","captureStackTrace","writable","createDOMExceptionPolyfill","ReadableStreamPipeTo","source","preventClose","preventAbort","signal","shuttingDown","currentWrite","actions","shutdownWithAction","all","map","action","aborted","addEventListener","isOrBecomesErrored","shutdown","WritableStreamDefaultWriterCloseWithErrorPropagation","destClosed","waitForWritesToFinish","oldCurrentWrite","originalIsError","originalError","doTheRest","finalize","newError","isError","removeEventListener","resolveLoop","rejectLoop","resolveRead","rejectRead","ReadableStreamDefaultController","IsReadableStreamDefaultController","defaultControllerBrandCheckException$1","ReadableStreamDefaultControllerGetDesiredSize","ReadableStreamDefaultControllerCanCloseOrEnqueue","ReadableStreamDefaultControllerClose","ReadableStreamDefaultControllerEnqueue","ReadableStreamDefaultControllerError","ReadableStreamDefaultControllerClearAlgorithms","_controlledReadableStream","ReadableStreamDefaultControllerCallPullIfNeeded","ReadableStreamDefaultControllerShouldCallPull","SetUpReadableStreamDefaultController","convertUnderlyingSourceCancelCallback","convertUnderlyingSourcePullCallback","convertUnderlyingSourceStartCallback","convertReadableStreamType","convertReadableStreamReaderMode","mode","convertPipeOptions","options","isAbortSignal","assertAbortSignal","ReadableStream","rawUnderlyingSource","underlyingSource","convertUnderlyingDefaultOrByteSource","InitializeReadableStream","SetUpReadableStreamDefaultControllerFromUnderlyingSource","streamBrandCheckException$1","getReader","rawOptions","convertReaderOptions","pipeThrough","rawTransform","transform","readable","convertReadableWritablePair","pipeTo","destination","tee","branches","cloneForBranch2","reason1","reason2","branch1","branch2","resolveCancelPromise","reading","canceled1","canceled2","cancelPromise","value1","value2","CreateReadableStream","compositeReason","cancelResult","ReadableStreamTee","values","impl","AcquireReadableStreamAsyncIterator","convertIteratorOptions","convertQueuingStrategyInit","byteLengthSizeFunction","ByteLengthQueuingStrategy","_byteLengthQueuingStrategyHighWaterMark","IsByteLengthQueuingStrategy","byteLengthBrandCheckException","countSizeFunction","CountQueuingStrategy","_countQueuingStrategyHighWaterMark","IsCountQueuingStrategy","countBrandCheckException","convertTransformerFlushCallback","convertTransformerStartCallback","convertTransformerTransformCallback","TransformStream","rawTransformer","rawWritableStrategy","rawReadableStrategy","writableStrategy","readableStrategy","transformer","flush","readableType","writableType","convertTransformer","readableHighWaterMark","readableSizeAlgorithm","writableHighWaterMark","writableSizeAlgorithm","startPromise_resolve","startPromise","_transformStreamController","_backpressureChangePromise","_writable","TransformStreamDefaultControllerPerformTransform","TransformStreamDefaultSinkWriteAlgorithm","TransformStreamError","TransformStreamDefaultSinkAbortAlgorithm","_readable","flushPromise","_flushAlgorithm","TransformStreamDefaultControllerClearAlgorithms","TransformStreamDefaultSinkCloseAlgorithm","TransformStreamSetBackpressure","TransformStreamDefaultSourcePullAlgorithm","TransformStreamErrorWritableAndUnblockWrite","CreateWritableStream","_backpressureChangePromise_resolve","InitializeTransformStream","TransformStreamDefaultController","transformAlgorithm","TransformStreamDefaultControllerEnqueue","transformResultE","flushAlgorithm","_controlledTransformStream","_transformAlgorithm","SetUpTransformStreamDefaultController","SetUpTransformStreamDefaultControllerFromTransformer","IsTransformStream","streamBrandCheckException","IsTransformStreamDefaultController","defaultControllerBrandCheckException","terminate","TransformStreamDefaultControllerTerminate","readableController","ReadableStreamDefaultControllerHasBackpressure"],"mappings":"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"}